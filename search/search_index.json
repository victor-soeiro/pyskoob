{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySkoob Documentation","text":"<p>Welcome to the PySkoob documentation. This site provides usage examples and a reference of the available services.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyskoob\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    books = client.books.search(\"python\").results\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":"<p>Client facades bundling synchronous and asynchronous services.</p> <p>Authentication helpers and session management for Skoob.</p>"},{"location":"#pyskoob.client.SkoobAsyncClient","title":"<code>SkoobAsyncClient</code>","text":"<p>Facade for interacting with Skoob services asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>http_client</code> <code>AsyncHTTPClient | None</code> <p>Optional pre-configured HTTP client implementing :class:<code>AsyncHTTPClient</code>. When provided, <code>rate_limiter</code> and <code>client_kwargs</code> are ignored.</p> <code>None</code> <code>rate_limiter</code> <code>RateLimiter | None</code> <p>Optional rate limiter used to throttle requests. When <code>http_client</code> is <code>None</code>, a default limiter allowing one request per second is used.</p> <code>None</code> <code>**client_kwargs</code> <code>Any</code> <p>Additional keyword arguments forwarded to <code>httpx.AsyncClient</code> when the default client is constructed.</p> <code>{}</code> Source code in <code>pyskoob/client.py</code> <pre><code>class SkoobAsyncClient:\n    \"\"\"Facade for interacting with Skoob services asynchronously.\n\n    Parameters\n    ----------\n    http_client:\n        Optional pre-configured HTTP client implementing :class:`AsyncHTTPClient`.\n        When provided, ``rate_limiter`` and ``client_kwargs`` are ignored.\n    rate_limiter:\n        Optional rate limiter used to throttle requests. When ``http_client`` is\n        ``None``, a default limiter allowing one request per second is used.\n    **client_kwargs:\n        Additional keyword arguments forwarded to ``httpx.AsyncClient`` when the\n        default client is constructed.\n    \"\"\"\n\n    def __init__(\n        self,\n        http_client: AsyncHTTPClient | None = None,\n        *,\n        rate_limiter: RateLimiter | None = None,\n        **client_kwargs: Any,\n    ) -&gt; None:\n        if http_client is not None:\n            self._client = http_client\n        else:\n            self._client = HttpxAsyncClient(rate_limiter=rate_limiter, **client_kwargs)\n        self.auth = AsyncAuthService(self._client)\n        self.books = AsyncBookService(self._client)\n        self.authors = AsyncAuthorService(self._client)\n        self.users = AsyncUserService(self._client, self.auth)\n        self.me = AsyncSkoobProfileService(self._client, self.auth)\n        self.publishers = AsyncPublisherService(self._client)\n\n    async def __aenter__(self) -&gt; SkoobAsyncClient:\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; bool | None:\n        await self.close()\n        return None\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the underlying HTTP client.\n\n        Examples\n        --------\n        &gt;&gt;&gt; client = SkoobAsyncClient()\n        &gt;&gt;&gt; await client.close()\n        \"\"\"\n        await self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobAsyncClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the underlying HTTP client.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = SkoobAsyncClient()\n&gt;&gt;&gt; await client.close()\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the underlying HTTP client.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = SkoobAsyncClient()\n    &gt;&gt;&gt; await client.close()\n    \"\"\"\n    await self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient","title":"<code>SkoobClient</code>","text":"<p>Facade for interacting with Skoob services.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with SkoobClient() as client:\n...     client.auth.login_with_cookies(\"token\")\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>class SkoobClient:\n    \"\"\"Facade for interacting with Skoob services.\n\n    Examples\n    --------\n    &gt;&gt;&gt; with SkoobClient() as client:\n    ...     client.auth.login_with_cookies(\"token\")\n    \"\"\"\n\n    def __init__(self, rate_limiter: RateLimiter | None = None) -&gt; None:\n        \"\"\"Initializes the SkoobClient.\n\n        Parameters\n        ----------\n        rate_limiter:\n            Optional rate limiter used to throttle requests. If ``None``, a\n            default limiter allowing one request per second is used.\n        \"\"\"\n\n        self._client = HttpxSyncClient(rate_limiter=rate_limiter)\n        self.auth = AuthService(self._client)\n        self.books = BookService(self._client)\n        self.authors = AuthorService(self._client)\n        self.users = UserService(self._client, self.auth)\n        self.me = SkoobProfileService(self._client, self.auth)\n        self.publishers = PublisherService(self._client)\n\n    def __enter__(self) -&gt; SkoobClient:\n        \"\"\"\n        Enter the runtime context for the SkoobClient.\n\n        Returns\n        -------\n        SkoobClient\n            The SkoobClient instance.\n\n        Examples\n        --------\n        &gt;&gt;&gt; with SkoobClient() as client:\n        ...     pass\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; bool | None:\n        \"\"\"\n        Exit the runtime context, closing the HTTPX client.\n\n        Parameters\n        ----------\n        exc_type : type\n            The exception type.\n        exc_val : Exception\n            The exception value.\n        exc_tb : traceback\n            The traceback object.\n\n        Returns\n        -------\n        bool or None\n            ``True`` to suppress the exception; otherwise ``None`` or ``False``\n            to propagate it.\n\n        Examples\n        --------\n        &gt;&gt;&gt; client = SkoobClient()\n        &gt;&gt;&gt; client.__exit__(None, None, None)\n        None\n        \"\"\"\n        self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the SkoobClient.</p> <p>Returns:</p> Type Description <code>SkoobClient</code> <p>The SkoobClient instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with SkoobClient() as client:\n...     pass\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>def __enter__(self) -&gt; SkoobClient:\n    \"\"\"\n    Enter the runtime context for the SkoobClient.\n\n    Returns\n    -------\n    SkoobClient\n        The SkoobClient instance.\n\n    Examples\n    --------\n    &gt;&gt;&gt; with SkoobClient() as client:\n    ...     pass\n    \"\"\"\n    return self\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context, closing the HTTPX client.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception value.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback object.</p> required <p>Returns:</p> Type Description <code>bool or None</code> <p><code>True</code> to suppress the exception; otherwise <code>None</code> or <code>False</code> to propagate it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = SkoobClient()\n&gt;&gt;&gt; client.__exit__(None, None, None)\nNone\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; bool | None:\n    \"\"\"\n    Exit the runtime context, closing the HTTPX client.\n\n    Parameters\n    ----------\n    exc_type : type\n        The exception type.\n    exc_val : Exception\n        The exception value.\n    exc_tb : traceback\n        The traceback object.\n\n    Returns\n    -------\n    bool or None\n        ``True`` to suppress the exception; otherwise ``None`` or ``False``\n        to propagate it.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = SkoobClient()\n    &gt;&gt;&gt; client.__exit__(None, None, None)\n    None\n    \"\"\"\n    self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__init__","title":"<code>__init__(rate_limiter=None)</code>","text":"<p>Initializes the SkoobClient.</p> <p>Parameters:</p> Name Type Description Default <code>rate_limiter</code> <code>RateLimiter | None</code> <p>Optional rate limiter used to throttle requests. If <code>None</code>, a default limiter allowing one request per second is used.</p> <code>None</code> Source code in <code>pyskoob/client.py</code> <pre><code>def __init__(self, rate_limiter: RateLimiter | None = None) -&gt; None:\n    \"\"\"Initializes the SkoobClient.\n\n    Parameters\n    ----------\n    rate_limiter:\n        Optional rate limiter used to throttle requests. If ``None``, a\n        default limiter allowing one request per second is used.\n    \"\"\"\n\n    self._client = HttpxSyncClient(rate_limiter=rate_limiter)\n    self.auth = AuthService(self._client)\n    self.books = BookService(self._client)\n    self.authors = AuthorService(self._client)\n    self.users = UserService(self._client, self.auth)\n    self.me = SkoobProfileService(self._client, self.auth)\n    self.publishers = PublisherService(self._client)\n</code></pre>"},{"location":"#pyskoob.auth.AsyncAuthService","title":"<code>AsyncAuthService</code>","text":"<p>               Bases: <code>AsyncBaseSkoobService</code></p> <p>Asynchronous authentication service.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>class AsyncAuthService(AsyncBaseSkoobService):  # pragma: no cover - thin async wrapper\n    \"\"\"Asynchronous authentication service.\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        super().__init__(client)\n        self._is_logged_in = False\n\n    async def login_with_cookies(self, session_token: str) -&gt; User:\n        \"\"\"Log in using a pre-existing session token.\n\n        Parameters\n        ----------\n        session_token : str\n            The PHPSESSID token from Skoob.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n        \"\"\"\n\n        logger.info(\"Attempting to log in with session token.\")\n        self.client.cookies.update({\"PHPSESSID\": session_token})\n        user = await self.get_my_info()\n        self._is_logged_in = True\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    async def login(self, email: str, password: str) -&gt; User:\n        \"\"\"Log in using email and password.\n\n        Parameters\n        ----------\n        email : str\n            The user's email address.\n        password : str\n            The user's password.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n        \"\"\"\n\n        logger.info(\"Attempting to log in with email and password.\")\n        url = f\"{self.base_url}/v1/login\"\n        data = {\n            \"data[Usuario][email]\": email,\n            \"data[Usuario][senha]\": password,\n            \"data[Login][automatico]\": True,\n        }\n        response = await self.client.post(url, data=data)\n        response.raise_for_status()\n        try:\n            json_data = response.json()\n        except ValueError as exc:\n            logger.error(\"Login response was not valid JSON\")\n            raise ConnectionError(\"Invalid response format\") from exc\n        if not json_data.get(\"success\", False):\n            logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n            raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n        self._is_logged_in = True\n        user = await self.get_my_info()\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    async def get_my_info(self) -&gt; User:\n        \"\"\"Retrieve information about the authenticated user.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n        \"\"\"\n\n        logger.info(\"Getting authenticated user's information.\")\n        url = f\"{self.base_url}/v1/user/stats:true\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n            raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]\n        user = User.model_validate(user_data)\n        logger.info(\"Successfully retrieved user: '%s'\", user.name)\n        return user\n\n    async def validate_login(self) -&gt; None:\n        \"\"\"Validate that the current session is authenticated.\n\n        Notes\n        -----\n        This method performs no I/O but remains asynchronous for API\n        consistency across async services.\n\n        Raises\n        ------\n        PermissionError\n            If the user is not logged in.\n        \"\"\"\n\n        logger.debug(\"Validating login status.\")\n        if not self._is_logged_in:\n            logger.warning(\"Validation failed: User is not logged in.\")\n            raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n        logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#pyskoob.auth.AsyncAuthService.get_my_info","title":"<code>get_my_info()</code>  <code>async</code>","text":"<p>Retrieve information about the authenticated user.</p> <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>async def get_my_info(self) -&gt; User:\n    \"\"\"Retrieve information about the authenticated user.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n    \"\"\"\n\n    logger.info(\"Getting authenticated user's information.\")\n    url = f\"{self.base_url}/v1/user/stats:true\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n        raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]\n    user = User.model_validate(user_data)\n    logger.info(\"Successfully retrieved user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AsyncAuthService.login","title":"<code>login(email, password)</code>  <code>async</code>","text":"<p>Log in using email and password.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The user's email address.</p> required <code>password</code> <code>str</code> <p>The user's password.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>async def login(self, email: str, password: str) -&gt; User:\n    \"\"\"Log in using email and password.\n\n    Parameters\n    ----------\n    email : str\n        The user's email address.\n    password : str\n        The user's password.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n    \"\"\"\n\n    logger.info(\"Attempting to log in with email and password.\")\n    url = f\"{self.base_url}/v1/login\"\n    data = {\n        \"data[Usuario][email]\": email,\n        \"data[Usuario][senha]\": password,\n        \"data[Login][automatico]\": True,\n    }\n    response = await self.client.post(url, data=data)\n    response.raise_for_status()\n    try:\n        json_data = response.json()\n    except ValueError as exc:\n        logger.error(\"Login response was not valid JSON\")\n        raise ConnectionError(\"Invalid response format\") from exc\n    if not json_data.get(\"success\", False):\n        logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n        raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n    self._is_logged_in = True\n    user = await self.get_my_info()\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AsyncAuthService.login_with_cookies","title":"<code>login_with_cookies(session_token)</code>  <code>async</code>","text":"<p>Log in using a pre-existing session token.</p> <p>Parameters:</p> Name Type Description Default <code>session_token</code> <code>str</code> <p>The PHPSESSID token from Skoob.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>async def login_with_cookies(self, session_token: str) -&gt; User:\n    \"\"\"Log in using a pre-existing session token.\n\n    Parameters\n    ----------\n    session_token : str\n        The PHPSESSID token from Skoob.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n    \"\"\"\n\n    logger.info(\"Attempting to log in with session token.\")\n    self.client.cookies.update({\"PHPSESSID\": session_token})\n    user = await self.get_my_info()\n    self._is_logged_in = True\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AsyncAuthService.validate_login","title":"<code>validate_login()</code>  <code>async</code>","text":"<p>Validate that the current session is authenticated.</p> Notes <p>This method performs no I/O but remains asynchronous for API consistency across async services.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the user is not logged in.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>async def validate_login(self) -&gt; None:\n    \"\"\"Validate that the current session is authenticated.\n\n    Notes\n    -----\n    This method performs no I/O but remains asynchronous for API\n    consistency across async services.\n\n    Raises\n    ------\n    PermissionError\n        If the user is not logged in.\n    \"\"\"\n\n    logger.debug(\"Validating login status.\")\n    if not self._is_logged_in:\n        logger.warning(\"Validation failed: User is not logged in.\")\n        raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n    logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#pyskoob.auth.AuthService","title":"<code>AuthService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> <p>Handle authentication with Skoob and track login state.</p> <p>The service exposes login helpers and validates whether requests are performed as an authenticated user. Other high-level services depend on this class to ensure session-sensitive operations are authorized.</p> Source code in <code>pyskoob/auth.py</code> <pre><code>class AuthService(BaseSkoobService):\n    \"\"\"Handle authentication with Skoob and track login state.\n\n    The service exposes login helpers and validates whether requests are\n    performed as an authenticated user. Other high-level services depend on\n    this class to ensure session-sensitive operations are authorized.\n    \"\"\"\n\n    def __init__(self, client: SyncHTTPClient):\n        \"\"\"Manage Skoob authentication and session validation.\n\n        The service wraps the login workflow and stores the session state so\n        other services (such as :class:`UserService` or\n        :class:`SkoobProfileService`) can verify that requests are\n        authenticated before accessing user data.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import httpx\n        &gt;&gt;&gt; service = AuthService(httpx.Client())\n        \"\"\"\n        super().__init__(client)\n        self._is_logged_in = False\n\n    def login_with_cookies(self, session_token: str) -&gt; User:\n        \"\"\"\n        Logs in the user using a session token.\n\n        Parameters\n        ----------\n        session_token : str\n            The PHPSESSID token from Skoob.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Raises\n        ------\n        ConnectionError\n            If retrieving user information fails.\n        PermissionError\n            If the provided session token is invalid or expired.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\n        User(name='example')\n        \"\"\"\n        logger.info(\"Attempting to log in with session token.\")\n        self.client.cookies.update({\"PHPSESSID\": session_token})\n        user = self.get_my_info()\n        self._is_logged_in = True\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    def login(self, email: str, password: str) -&gt; User:\n        \"\"\"\n        Logs in the user using email and password.\n\n        Parameters\n        ----------\n        email : str\n            The user's email address.\n        password : str\n            The user's password.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Raises\n        ------\n        ConnectionError\n            If authentication fails or the session cannot be established.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\n        User(name='example')\n        \"\"\"\n        logger.info(\"Attempting to log in with email and password.\")\n        url = f\"{self.base_url}/v1/login\"\n        data = {\n            \"data[Usuario][email]\": email,\n            \"data[Usuario][senha]\": password,\n            \"data[Login][automatico]\": True,\n        }\n\n        response = self.client.post(url, data=data)\n        response.raise_for_status()\n\n        try:\n            json_data = response.json()\n        except ValueError as exc:\n            logger.error(\"Login response was not valid JSON\")\n            raise ConnectionError(\"Invalid response format\") from exc\n        if not json_data.get(\"success\", False):\n            logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n            raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n\n        self._is_logged_in = True\n        user = self.get_my_info()\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    def get_my_info(self) -&gt; User:\n        \"\"\"\n        Retrieves the authenticated user's information.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Raises\n        ------\n        ConnectionError\n            If it fails to retrieve user information.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_my_info().name\n        'Example User'\n        \"\"\"\n        logger.info(\"Getting authenticated user's information.\")\n        url = f\"{self.base_url}/v1/user/stats:true\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n            raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n        user = User.model_validate(user_data)\n        logger.info(\"Successfully retrieved user: '%s'\", user.name)\n        return user\n\n    def validate_login(self) -&gt; None:\n        \"\"\"\n        Validates if the user is logged in.\n\n        Raises\n        ------\n        PermissionError\n            If the user is not logged in.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.validate_login()\n        None\n        \"\"\"\n        logger.debug(\"Validating login status.\")\n        if not self._is_logged_in:\n            logger.warning(\"Validation failed: User is not logged in.\")\n            raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n        logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.__init__","title":"<code>__init__(client)</code>","text":"<p>Manage Skoob authentication and session validation.</p> <p>The service wraps the login workflow and stores the session state so other services (such as :class:<code>UserService</code> or :class:<code>SkoobProfileService</code>) can verify that requests are authenticated before accessing user data.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import httpx\n&gt;&gt;&gt; service = AuthService(httpx.Client())\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def __init__(self, client: SyncHTTPClient):\n    \"\"\"Manage Skoob authentication and session validation.\n\n    The service wraps the login workflow and stores the session state so\n    other services (such as :class:`UserService` or\n    :class:`SkoobProfileService`) can verify that requests are\n    authenticated before accessing user data.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import httpx\n    &gt;&gt;&gt; service = AuthService(httpx.Client())\n    \"\"\"\n    super().__init__(client)\n    self._is_logged_in = False\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.get_my_info","title":"<code>get_my_info()</code>","text":"<p>Retrieves the authenticated user's information.</p> <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If it fails to retrieve user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_my_info().name\n'Example User'\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def get_my_info(self) -&gt; User:\n    \"\"\"\n    Retrieves the authenticated user's information.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Raises\n    ------\n    ConnectionError\n        If it fails to retrieve user information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_my_info().name\n    'Example User'\n    \"\"\"\n    logger.info(\"Getting authenticated user's information.\")\n    url = f\"{self.base_url}/v1/user/stats:true\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n        raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n    user = User.model_validate(user_data)\n    logger.info(\"Successfully retrieved user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.login","title":"<code>login(email, password)</code>","text":"<p>Logs in the user using email and password.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The user's email address.</p> required <code>password</code> <code>str</code> <p>The user's password.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If authentication fails or the session cannot be established.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\nUser(name='example')\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def login(self, email: str, password: str) -&gt; User:\n    \"\"\"\n    Logs in the user using email and password.\n\n    Parameters\n    ----------\n    email : str\n        The user's email address.\n    password : str\n        The user's password.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Raises\n    ------\n    ConnectionError\n        If authentication fails or the session cannot be established.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\n    User(name='example')\n    \"\"\"\n    logger.info(\"Attempting to log in with email and password.\")\n    url = f\"{self.base_url}/v1/login\"\n    data = {\n        \"data[Usuario][email]\": email,\n        \"data[Usuario][senha]\": password,\n        \"data[Login][automatico]\": True,\n    }\n\n    response = self.client.post(url, data=data)\n    response.raise_for_status()\n\n    try:\n        json_data = response.json()\n    except ValueError as exc:\n        logger.error(\"Login response was not valid JSON\")\n        raise ConnectionError(\"Invalid response format\") from exc\n    if not json_data.get(\"success\", False):\n        logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n        raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n\n    self._is_logged_in = True\n    user = self.get_my_info()\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.login_with_cookies","title":"<code>login_with_cookies(session_token)</code>","text":"<p>Logs in the user using a session token.</p> <p>Parameters:</p> Name Type Description Default <code>session_token</code> <code>str</code> <p>The PHPSESSID token from Skoob.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If retrieving user information fails.</p> <code>PermissionError</code> <p>If the provided session token is invalid or expired.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\nUser(name='example')\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def login_with_cookies(self, session_token: str) -&gt; User:\n    \"\"\"\n    Logs in the user using a session token.\n\n    Parameters\n    ----------\n    session_token : str\n        The PHPSESSID token from Skoob.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Raises\n    ------\n    ConnectionError\n        If retrieving user information fails.\n    PermissionError\n        If the provided session token is invalid or expired.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\n    User(name='example')\n    \"\"\"\n    logger.info(\"Attempting to log in with session token.\")\n    self.client.cookies.update({\"PHPSESSID\": session_token})\n    user = self.get_my_info()\n    self._is_logged_in = True\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.validate_login","title":"<code>validate_login()</code>","text":"<p>Validates if the user is logged in.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the user is not logged in.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.validate_login()\nNone\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def validate_login(self) -&gt; None:\n    \"\"\"\n    Validates if the user is logged in.\n\n    Raises\n    ------\n    PermissionError\n        If the user is not logged in.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.validate_login()\n    None\n    \"\"\"\n    logger.debug(\"Validating login status.\")\n    if not self._is_logged_in:\n        logger.warning(\"Validation failed: User is not logged in.\")\n        raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n    logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#further-reading","title":"Further Reading","text":"<ul> <li>Advanced Usage</li> <li>Stable Public API</li> </ul>"},{"location":"advanced_usage/","title":"Advanced Usage","text":"<p>This section shows more involved examples of working with PySkoob.</p>"},{"location":"advanced_usage/#handling-pagination","title":"Handling Pagination","text":"<p>Several services return a <code>Pagination</code> object that exposes the <code>has_next_page</code> flag. You can use this flag to iterate over all pages:</p> <pre><code>from pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookSearch\n\nwith SkoobClient() as client:\n    page = 1\n    while True:\n        results = client.books.search(\"Python\", BookSearch.TITLE, page=page)\n        for book in results.results:\n            print(f\"[{page}] {book.title}\")\n        if not results.has_next_page:\n            break\n        page += 1\n</code></pre>"},{"location":"advanced_usage/#asynchronous-http-client","title":"Asynchronous HTTP Client","text":"<p>PySkoob ships with <code>HttpxAsyncClient</code> for making asynchronous HTTP requests. While the high level services are synchronous, you can use the async client when integrating with an async application:</p> <pre><code>import asyncio\nfrom pyskoob import HttpxAsyncClient\n\nasync def main() -&gt; None:\n    async with HttpxAsyncClient() as client:\n        resp = await client.get(\"https://www.skoob.com.br\")\n        print(resp.text[:100])\n\nasyncio.run(main())\n</code></pre>"},{"location":"author_service/","title":"Author Service","text":"<p>The <code>AuthorService</code> provides search capabilities for authors on Skoob. It scrapes Skoob's HTML pages and returns lightweight results with the following fields:</p> <ul> <li><code>id</code>: numeric identifier extracted from the author URL</li> <li><code>name</code>: the author's display name</li> <li><code>nickname</code>: nickname shown below the name</li> <li><code>url</code>: absolute URL to the author's page on Skoob</li> <li><code>img_url</code>: avatar image URL</li> </ul> <p>Skoob displays publication, reader and follower counts on the search results page, but these values are often outdated when compared with the author's profile page. To avoid exposing misleading data, <code>AuthorService</code> intentionally omits these numbers.</p>"},{"location":"author_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    results = client.authors.search(\"Asimov\")\n    for author in results.results:\n        print(author.name, author.id)\n    if results.has_next_page:\n        # fetch the next page of results\n        more_results = client.authors.search(\"Asimov\", page=results.next_page)\n</code></pre> <p><code>search()</code> returns only the first page of results. Use <code>results.has_next_page</code> to fetch additional pages.</p> <p>Services for retrieving authors and their works from Skoob.</p>"},{"location":"author_service/#pyskoob.authors.AsyncAuthorService","title":"<code>AsyncAuthorService</code>","text":"<p>               Bases: <code>AsyncBaseSkoobService</code></p> <p>Asynchronous variant of :class:<code>AuthorService</code>.</p> Source code in <code>pyskoob/authors.py</code> <pre><code>class AsyncAuthorService(AsyncBaseSkoobService):  # pragma: no cover - thin async wrapper\n    \"\"\"Asynchronous variant of :class:`AuthorService`.\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        super().__init__(client)\n\n    async def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n        \"\"\"Asynchronously search for authors by name.\n\n        Parameters\n        ----------\n        query : str\n            Term to look for.\n        page : int, optional\n            Page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[AuthorSearchResult]\n            Paginated list of authors matching the query.\n        \"\"\"\n\n        url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n        logger.info(\"Searching authors with query '%s' page %s\", query, page)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            author_blocks = []\n            for div in safe_find_all(soup, \"div\"):\n                style = str(div.get(\"style\") or \"\")\n                if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n                    author_blocks.append(div)\n            results = [r for div in author_blocks if (r := parse_author_block(div, self.base_url))]\n            total = extract_total_results(soup)\n            has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=results,\n                limit=len(results),\n                page=page,\n                total=total,\n                has_next_page=has_next,\n            )\n        except Exception as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to search authors: %s\", exc, exc_info=True)\n            return Pagination(\n                results=[],\n                limit=0,\n                page=page,\n                total=0,\n                has_next_page=False,\n            )\n\n    async def get_by_id(self, author_id: int) -&gt; AuthorProfile:\n        \"\"\"Fetch an author's profile by identifier.\n\n        Parameters\n        ----------\n        author_id : int\n            Identifier of the author on Skoob.\n\n        Returns\n        -------\n        AuthorProfile\n            Structured profile data for the requested author.\n        \"\"\"\n\n        url = f\"{self.base_url}/autor/{author_id}\"\n        logger.info(\"Fetching author profile: %s\", url)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            return parse_author_profile(soup, self.base_url)\n        except Exception as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to fetch author profile %s: %s\", author_id, exc, exc_info=True)\n            raise ParsingError(\"Failed to fetch author profile.\") from exc\n\n    async def get_books(self, author_id: int, page: int = 1) -&gt; Pagination[BookSearchResult]:\n        \"\"\"Fetch books written by the given author.\n\n        Parameters\n        ----------\n        author_id : int\n            The author identifier.\n        page : int, optional\n            Pagination page, by default ``1``.\n\n        Returns\n        -------\n        Pagination[BookSearchResult]\n            Paginated list of books authored by the given ID.\n        \"\"\"\n\n        url = f\"{self.base_url}/autor/livros/{author_id}/page:{page}\"\n        logger.info(\"Fetching books for author %s page %s\", author_id, page)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            books = [parse_author_book_div(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"clivro livro-capa-mini\"})]\n            books = [b for b in books if b]\n            total_span = safe_find(soup, \"span\", {\"class\": \"badge badge-ativa\"})\n            total_text = get_tag_text(total_span).replace(\".\", \"\")\n            total = int(total_text) if total_text.isdigit() else len(books)\n            has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=books,\n                total=total,\n                page=page,\n                limit=len(books),\n                has_next_page=has_next,\n            )\n        except Exception as exc:  # pragma: no cover - defensive\n            logger.error(\n                \"Failed to fetch books for author %s: %s\",\n                author_id,\n                exc,\n                exc_info=True,\n            )\n            return Pagination(\n                results=[],\n                total=0,\n                page=page,\n                limit=0,\n                has_next_page=False,\n            )\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AsyncAuthorService.get_books","title":"<code>get_books(author_id, page=1)</code>  <code>async</code>","text":"<p>Fetch books written by the given author.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>int</code> <p>The author identifier.</p> required <code>page</code> <code>int</code> <p>Pagination page, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookSearchResult]</code> <p>Paginated list of books authored by the given ID.</p> Source code in <code>pyskoob/authors.py</code> <pre><code>async def get_books(self, author_id: int, page: int = 1) -&gt; Pagination[BookSearchResult]:\n    \"\"\"Fetch books written by the given author.\n\n    Parameters\n    ----------\n    author_id : int\n        The author identifier.\n    page : int, optional\n        Pagination page, by default ``1``.\n\n    Returns\n    -------\n    Pagination[BookSearchResult]\n        Paginated list of books authored by the given ID.\n    \"\"\"\n\n    url = f\"{self.base_url}/autor/livros/{author_id}/page:{page}\"\n    logger.info(\"Fetching books for author %s page %s\", author_id, page)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        books = [parse_author_book_div(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"clivro livro-capa-mini\"})]\n        books = [b for b in books if b]\n        total_span = safe_find(soup, \"span\", {\"class\": \"badge badge-ativa\"})\n        total_text = get_tag_text(total_span).replace(\".\", \"\")\n        total = int(total_text) if total_text.isdigit() else len(books)\n        has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=books,\n            total=total,\n            page=page,\n            limit=len(books),\n            has_next_page=has_next,\n        )\n    except Exception as exc:  # pragma: no cover - defensive\n        logger.error(\n            \"Failed to fetch books for author %s: %s\",\n            author_id,\n            exc,\n            exc_info=True,\n        )\n        return Pagination(\n            results=[],\n            total=0,\n            page=page,\n            limit=0,\n            has_next_page=False,\n        )\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AsyncAuthorService.get_by_id","title":"<code>get_by_id(author_id)</code>  <code>async</code>","text":"<p>Fetch an author's profile by identifier.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>int</code> <p>Identifier of the author on Skoob.</p> required <p>Returns:</p> Type Description <code>AuthorProfile</code> <p>Structured profile data for the requested author.</p> Source code in <code>pyskoob/authors.py</code> <pre><code>async def get_by_id(self, author_id: int) -&gt; AuthorProfile:\n    \"\"\"Fetch an author's profile by identifier.\n\n    Parameters\n    ----------\n    author_id : int\n        Identifier of the author on Skoob.\n\n    Returns\n    -------\n    AuthorProfile\n        Structured profile data for the requested author.\n    \"\"\"\n\n    url = f\"{self.base_url}/autor/{author_id}\"\n    logger.info(\"Fetching author profile: %s\", url)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        return parse_author_profile(soup, self.base_url)\n    except Exception as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to fetch author profile %s: %s\", author_id, exc, exc_info=True)\n        raise ParsingError(\"Failed to fetch author profile.\") from exc\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AsyncAuthorService.search","title":"<code>search(query, page=1)</code>  <code>async</code>","text":"<p>Asynchronously search for authors by name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Term to look for.</p> required <code>page</code> <code>int</code> <p>Page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[AuthorSearchResult]</code> <p>Paginated list of authors matching the query.</p> Source code in <code>pyskoob/authors.py</code> <pre><code>async def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n    \"\"\"Asynchronously search for authors by name.\n\n    Parameters\n    ----------\n    query : str\n        Term to look for.\n    page : int, optional\n        Page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[AuthorSearchResult]\n        Paginated list of authors matching the query.\n    \"\"\"\n\n    url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n    logger.info(\"Searching authors with query '%s' page %s\", query, page)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        author_blocks = []\n        for div in safe_find_all(soup, \"div\"):\n            style = str(div.get(\"style\") or \"\")\n            if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n                author_blocks.append(div)\n        results = [r for div in author_blocks if (r := parse_author_block(div, self.base_url))]\n        total = extract_total_results(soup)\n        has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=results,\n            limit=len(results),\n            page=page,\n            total=total,\n            has_next_page=has_next,\n        )\n    except Exception as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to search authors: %s\", exc, exc_info=True)\n        return Pagination(\n            results=[],\n            limit=0,\n            page=page,\n            total=0,\n            has_next_page=False,\n        )\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AuthorService","title":"<code>AuthorService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving authors.</p> <p>The service scrapes HTML pages from Skoob to return author search results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service = AuthorService(None)\n&gt;&gt;&gt; service.search(\"john\").results\n[]\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>class AuthorService(BaseSkoobService):\n    \"\"\"High level operations for retrieving authors.\n\n    The service scrapes HTML pages from Skoob to return author search results.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service = AuthorService(None)\n    &gt;&gt;&gt; service.search(\"john\").results\n    []\n    \"\"\"\n\n    def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n        \"\"\"Search for authors by name.\n\n        Parameters\n        ----------\n        query : str\n            Term to look for.\n        page : int, optional\n            Page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[AuthorSearchResult]\n            Paginated list of authors matching the query.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"john\").total\n        0\n        \"\"\"\n        url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n        logger.info(\"Searching authors with query '%s' page %s\", query, page)\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n\n        author_blocks = []\n        for div in safe_find_all(soup, \"div\"):\n            style = str(div.get(\"style\") or \"\")\n            if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n                author_blocks.append(div)\n\n        results = [r for div in author_blocks if (r := parse_author_block(div, self.base_url))]\n        total = extract_total_results(soup)\n        has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=results,\n            limit=len(results),\n            page=page,\n            total=total,\n            has_next_page=has_next,\n        )\n\n    # ------------------------------------------------------------------\n    # Author profile\n    def get_by_id(self, author_id: int) -&gt; AuthorProfile:\n        \"\"\"Retrieve detailed information about an author.\n\n        Parameters\n        ----------\n        author_id : int\n            Identifier of the author on Skoob.\n\n        Returns\n        -------\n        AuthorProfile\n            Structured profile data for the requested author.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).name\n        'Some Author'\n        \"\"\"\n\n        url = f\"{self.base_url}/autor/{author_id}\"\n        logger.info(\"Fetching author profile: %s\", url)\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        return parse_author_profile(soup, self.base_url)\n\n    # ------------------------------------------------------------------\n    # Author books\n    def get_books(self, author_id: int, page: int = 1) -&gt; Pagination[BookSearchResult]:\n        \"\"\"Retrieve books written by the author.\n\n        Parameters\n        ----------\n        author_id : int\n            The author identifier.\n        page : int, optional\n            Pagination page, by default ``1``.\n\n        Returns\n        -------\n        Pagination[BookSearchResult]\n            Paginated list of books authored by the given ID.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_books(1).results[0].title\n        'Book'\n        \"\"\"\n\n        url = f\"{self.base_url}/autor/livros/{author_id}/page:{page}\"\n        logger.info(\"Fetching books for author %s page %s\", author_id, page)\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n\n        books = [parse_author_book_div(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"clivro livro-capa-mini\"})]\n        books = [b for b in books if b]\n\n        total_span = safe_find(soup, \"span\", {\"class\": \"badge badge-ativa\"})\n        total_text = get_tag_text(total_span).replace(\".\", \"\")\n        total = int(total_text) if total_text.isdigit() else len(books)\n\n        has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n\n        return Pagination(\n            results=books,\n            total=total,\n            page=page,\n            limit=len(books),\n            has_next_page=has_next,\n        )\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AuthorService.get_books","title":"<code>get_books(author_id, page=1)</code>","text":"<p>Retrieve books written by the author.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>int</code> <p>The author identifier.</p> required <code>page</code> <code>int</code> <p>Pagination page, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookSearchResult]</code> <p>Paginated list of books authored by the given ID.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_books(1).results[0].title\n'Book'\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>def get_books(self, author_id: int, page: int = 1) -&gt; Pagination[BookSearchResult]:\n    \"\"\"Retrieve books written by the author.\n\n    Parameters\n    ----------\n    author_id : int\n        The author identifier.\n    page : int, optional\n        Pagination page, by default ``1``.\n\n    Returns\n    -------\n    Pagination[BookSearchResult]\n        Paginated list of books authored by the given ID.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_books(1).results[0].title\n    'Book'\n    \"\"\"\n\n    url = f\"{self.base_url}/autor/livros/{author_id}/page:{page}\"\n    logger.info(\"Fetching books for author %s page %s\", author_id, page)\n    response = self.client.get(url)\n    response.raise_for_status()\n    soup = self.parse_html(response.text)\n\n    books = [parse_author_book_div(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"clivro livro-capa-mini\"})]\n    books = [b for b in books if b]\n\n    total_span = safe_find(soup, \"span\", {\"class\": \"badge badge-ativa\"})\n    total_text = get_tag_text(total_span).replace(\".\", \"\")\n    total = int(total_text) if total_text.isdigit() else len(books)\n\n    has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n\n    return Pagination(\n        results=books,\n        total=total,\n        page=page,\n        limit=len(books),\n        has_next_page=has_next,\n    )\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AuthorService.get_by_id","title":"<code>get_by_id(author_id)</code>","text":"<p>Retrieve detailed information about an author.</p> <p>Parameters:</p> Name Type Description Default <code>author_id</code> <code>int</code> <p>Identifier of the author on Skoob.</p> required <p>Returns:</p> Type Description <code>AuthorProfile</code> <p>Structured profile data for the requested author.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).name\n'Some Author'\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>def get_by_id(self, author_id: int) -&gt; AuthorProfile:\n    \"\"\"Retrieve detailed information about an author.\n\n    Parameters\n    ----------\n    author_id : int\n        Identifier of the author on Skoob.\n\n    Returns\n    -------\n    AuthorProfile\n        Structured profile data for the requested author.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).name\n    'Some Author'\n    \"\"\"\n\n    url = f\"{self.base_url}/autor/{author_id}\"\n    logger.info(\"Fetching author profile: %s\", url)\n    response = self.client.get(url)\n    response.raise_for_status()\n    soup = self.parse_html(response.text)\n    return parse_author_profile(soup, self.base_url)\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AuthorService.search","title":"<code>search(query, page=1)</code>","text":"<p>Search for authors by name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Term to look for.</p> required <code>page</code> <code>int</code> <p>Page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[AuthorSearchResult]</code> <p>Paginated list of authors matching the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"john\").total\n0\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n    \"\"\"Search for authors by name.\n\n    Parameters\n    ----------\n    query : str\n        Term to look for.\n    page : int, optional\n        Page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[AuthorSearchResult]\n        Paginated list of authors matching the query.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"john\").total\n    0\n    \"\"\"\n    url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n    logger.info(\"Searching authors with query '%s' page %s\", query, page)\n    response = self.client.get(url)\n    response.raise_for_status()\n    soup = self.parse_html(response.text)\n\n    author_blocks = []\n    for div in safe_find_all(soup, \"div\"):\n        style = str(div.get(\"style\") or \"\")\n        if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n            author_blocks.append(div)\n\n    results = [r for div in author_blocks if (r := parse_author_block(div, self.base_url))]\n    total = extract_total_results(soup)\n    has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n    return Pagination(\n        results=results,\n        limit=len(results),\n        page=page,\n        total=total,\n        has_next_page=has_next,\n    )\n</code></pre>"},{"location":"books_service/","title":"Books Service","text":"<p>The <code>BookService</code> allows searching for books and retrieving detailed information.</p>"},{"location":"books_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookSearch\n\nwith SkoobClient() as client:\n    results = client.books.search(\"Duna\", BookSearch.TITLE)\n    for book in results.results:\n        print(book.title, book.book_id)\n</code></pre> <p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving and searching books.</p> <p>The service parses HTML and JSON responses from Skoob and exposes helpers to fetch book details, reviews and user lists. It can be used independently from authentication, but other services may combine it with :class:<code>AuthService</code> to operate on the authenticated user's data.</p> Source code in <code>pyskoob/books.py</code> <pre><code>class BookService(BaseSkoobService):\n    \"\"\"High level operations for retrieving and searching books.\n\n    The service parses HTML and JSON responses from Skoob and exposes\n    helpers to fetch book details, reviews and user lists. It can be used\n    independently from authentication, but other services may combine it\n    with :class:`AuthService` to operate on the authenticated user's data.\n    \"\"\"\n\n    def search(\n        self,\n        query: str,\n        search_by: BookSearch = BookSearch.TITLE,\n        page: int = 1,\n    ) -&gt; Pagination[BookSearchResult]:\n        \"\"\"\n        Searches for books by query and type.\n\n        Parameters\n        ----------\n        query : str\n            The search query string.\n        search_by : BookSearch, optional\n            The type of search (title, author, etc.), by default\n            ``BookSearch.TITLE``.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookSearchResult]\n            A paginated list of search results.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"Duna\").results[0].title\n        'Duna'\n        \"\"\"\n        url = f\"{self.base_url}/livro/lista/busca:{query}/tipo:{search_by.value}/mpage:{page}\"\n        logger.info(f\"Searching for books with query: '{query}' on page {page}\")\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n\n            limit = 30\n            results = [\n                parse_search_result(book_div, self.base_url)\n                for book_div in safe_find_all(soup, \"div\", {\"class\": \"box_lista_busca_vertical\"})\n            ]\n            cleaned_results: list[BookSearchResult] = [i for i in results if i]\n\n            total_results = extract_total_results(soup)\n            next_page_link = True if page * limit &lt; total_results else False\n        except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n            logger.error(f\"Failed to parse book search results: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse book search results.\") from e\n        except Exception as e:  # pragma: no cover - unexpected\n            logger.error(\n                f\"An unexpected error occurred during book search: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during book search.\") from e\n\n        logger.info(\n            \"Found %s books on page %s, total %s results.\",\n            len(results),\n            page,\n            total_results,\n        )\n        return Pagination[BookSearchResult](\n            results=cleaned_results,\n            limit=30,\n            page=page,\n            total=total_results,\n            has_next_page=next_page_link,\n        )\n\n    def get_by_id(self, edition_id: int) -&gt; Book:\n        \"\"\"\n        Retrieves a book by its edition ID.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        Book\n            Book object populated with detailed information.\n\n        Raises\n        ------\n        FileNotFoundError\n            If no book is found with the given edition_id.\n        ParsingError\n            If parsing or HTTP errors occur.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).title\n        'Some Book'\n        \"\"\"\n        logger.info(f\"Getting book by edition_id: {edition_id}\")\n        url = f\"{self.base_url}/v1/book/{edition_id}/stats:true\"\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            json_data = response.json().get(\"response\")\n            if not json_data:\n                cod_description = response.json().get(\"cod_description\", \"No description provided.\")\n                error_msg = f\"No data found for edition_id {edition_id}. Description: {cod_description}\"\n                logger.warning(error_msg)\n                raise FileNotFoundError(error_msg)\n            json_data = clean_book_json_data(json_data, self.base_url)\n            book = Book.model_validate(json_data)\n            logger.info(\n                \"Successfully retrieved book: '%s' (Edition ID: %s)\",\n                book.title,\n                edition_id,\n            )\n            return book\n        except FileNotFoundError:\n            raise\n        except Exception as e:  # pragma: no cover - unexpected\n            logger.error(\n                f\"Error retrieving book for edition_id {edition_id}: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(f\"Failed to retrieve book for edition_id {edition_id}.\") from e\n\n    def get_reviews(self, book_id: int, edition_id: int | None = None, page: int = 1) -&gt; Pagination[BookReview]:\n        \"\"\"\n        Retrieves reviews for a book.\n\n        Parameters\n        ----------\n        book_id : int\n            Book ID for which to retrieve reviews.\n        edition_id : int or None, optional\n            Specific edition ID, or auto-detected if None.\n        page : int, optional\n            Page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookReview]\n            A paginated list of reviews for the book.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes or parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_reviews(123).results\n        [...]\n        \"\"\"\n        url = f\"{self.base_url}/livro/resenhas/{book_id}/mpage:{page}/limit:50\"\n        if edition_id:\n            url += f\"/edition:{edition_id}\"\n        logger.info(f\"Getting reviews for book_id: {book_id}, page: {page}\")\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            if edition_id is None:\n                edition_id = extract_edition_id_from_reviews_page(soup)\n            book_reviews = [\n                review\n                for review in (parse_review(r, book_id, edition_id) for r in safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")}))\n                if review is not None\n            ]\n            next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n            logger.error(f\"Failed to parse book reviews: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse book reviews.\") from e\n        except Exception as e:  # pragma: no cover - unexpected\n            logger.error(\n                f\"An unexpected error occurred during review fetching: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during review fetching.\") from e\n        logger.info(f\"Found {len(book_reviews)} reviews on page {page}.\")\n        return Pagination[BookReview](\n            results=book_reviews,\n            limit=50,\n            page=page,\n            total=len(book_reviews),\n            has_next_page=next_page_link is not None,\n        )\n\n    def get_users_by_status(\n        self,\n        book_id: int,\n        status: BookUserStatus,\n        edition_id: int | None = None,\n        limit: int = 500,\n        page: int = 1,\n    ) -&gt; Pagination[int]:\n        \"\"\"\n        Retrieves users who have a book with a specific status.\n\n        Parameters\n        ----------\n        book_id : int\n            The ID of the book.\n        status : BookUserStatus\n            The status of the book in the user's shelf.\n        edition_id : int or None, optional\n            The edition ID of the book, by default None.\n        limit : int, optional\n            The number of users to retrieve per page, by default 500.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[int]\n            A paginated list of user IDs.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n        [1, 2, 3]\n        \"\"\"\n        url = f\"{self.base_url}/livro/leitores/{status.value}/{book_id}/limit:{limit}/page:{page}\"\n        if edition_id:\n            url += f\"/edition:{edition_id}\"\n        logger.info(\n            \"Getting users for book_id: %s with status '%s' on page %s\",\n            book_id,\n            status.value,\n            page,\n        )\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            users_id = extract_user_ids_from_html(soup)\n            next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n            logger.error(f\"Failed to parse users by status: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse users by status.\") from e\n        except Exception as e:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred during user status fetching: %s\",\n                e,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during user status fetching.\") from e\n        logger.info(\n            \"Found %s users on page %s.\",\n            len(users_id),\n            page,\n        )\n        return Pagination[int](\n            results=users_id,\n            limit=limit,\n            page=page,\n            total=len(users_id),\n            has_next_page=next_page_link is not None,\n        )\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_by_id","title":"<code>get_by_id(edition_id)</code>","text":"<p>Retrieves a book by its edition ID.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>Book</code> <p>Book object populated with detailed information.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no book is found with the given edition_id.</p> <code>ParsingError</code> <p>If parsing or HTTP errors occur.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).title\n'Some Book'\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_by_id(self, edition_id: int) -&gt; Book:\n    \"\"\"\n    Retrieves a book by its edition ID.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    Book\n        Book object populated with detailed information.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no book is found with the given edition_id.\n    ParsingError\n        If parsing or HTTP errors occur.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).title\n    'Some Book'\n    \"\"\"\n    logger.info(f\"Getting book by edition_id: {edition_id}\")\n    url = f\"{self.base_url}/v1/book/{edition_id}/stats:true\"\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json().get(\"response\")\n        if not json_data:\n            cod_description = response.json().get(\"cod_description\", \"No description provided.\")\n            error_msg = f\"No data found for edition_id {edition_id}. Description: {cod_description}\"\n            logger.warning(error_msg)\n            raise FileNotFoundError(error_msg)\n        json_data = clean_book_json_data(json_data, self.base_url)\n        book = Book.model_validate(json_data)\n        logger.info(\n            \"Successfully retrieved book: '%s' (Edition ID: %s)\",\n            book.title,\n            edition_id,\n        )\n        return book\n    except FileNotFoundError:\n        raise\n    except Exception as e:  # pragma: no cover - unexpected\n        logger.error(\n            f\"Error retrieving book for edition_id {edition_id}: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(f\"Failed to retrieve book for edition_id {edition_id}.\") from e\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_reviews","title":"<code>get_reviews(book_id, edition_id=None, page=1)</code>","text":"<p>Retrieves reviews for a book.</p> <p>Parameters:</p> Name Type Description Default <code>book_id</code> <code>int</code> <p>Book ID for which to retrieve reviews.</p> required <code>edition_id</code> <code>int or None</code> <p>Specific edition ID, or auto-detected if None.</p> <code>None</code> <code>page</code> <code>int</code> <p>Page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookReview]</code> <p>A paginated list of reviews for the book.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes or parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_reviews(123).results\n[...]\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_reviews(self, book_id: int, edition_id: int | None = None, page: int = 1) -&gt; Pagination[BookReview]:\n    \"\"\"\n    Retrieves reviews for a book.\n\n    Parameters\n    ----------\n    book_id : int\n        Book ID for which to retrieve reviews.\n    edition_id : int or None, optional\n        Specific edition ID, or auto-detected if None.\n    page : int, optional\n        Page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookReview]\n        A paginated list of reviews for the book.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes or parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_reviews(123).results\n    [...]\n    \"\"\"\n    url = f\"{self.base_url}/livro/resenhas/{book_id}/mpage:{page}/limit:50\"\n    if edition_id:\n        url += f\"/edition:{edition_id}\"\n    logger.info(f\"Getting reviews for book_id: {book_id}, page: {page}\")\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        if edition_id is None:\n            edition_id = extract_edition_id_from_reviews_page(soup)\n        book_reviews = [\n            review\n            for review in (parse_review(r, book_id, edition_id) for r in safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")}))\n            if review is not None\n        ]\n        next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n        logger.error(f\"Failed to parse book reviews: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse book reviews.\") from e\n    except Exception as e:  # pragma: no cover - unexpected\n        logger.error(\n            f\"An unexpected error occurred during review fetching: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during review fetching.\") from e\n    logger.info(f\"Found {len(book_reviews)} reviews on page {page}.\")\n    return Pagination[BookReview](\n        results=book_reviews,\n        limit=50,\n        page=page,\n        total=len(book_reviews),\n        has_next_page=next_page_link is not None,\n    )\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_users_by_status","title":"<code>get_users_by_status(book_id, status, edition_id=None, limit=500, page=1)</code>","text":"<p>Retrieves users who have a book with a specific status.</p> <p>Parameters:</p> Name Type Description Default <code>book_id</code> <code>int</code> <p>The ID of the book.</p> required <code>status</code> <code>BookUserStatus</code> <p>The status of the book in the user's shelf.</p> required <code>edition_id</code> <code>int or None</code> <p>The edition ID of the book, by default None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of users to retrieve per page, by default 500.</p> <code>500</code> <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[int]</code> <p>A paginated list of user IDs.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n[1, 2, 3]\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_users_by_status(\n    self,\n    book_id: int,\n    status: BookUserStatus,\n    edition_id: int | None = None,\n    limit: int = 500,\n    page: int = 1,\n) -&gt; Pagination[int]:\n    \"\"\"\n    Retrieves users who have a book with a specific status.\n\n    Parameters\n    ----------\n    book_id : int\n        The ID of the book.\n    status : BookUserStatus\n        The status of the book in the user's shelf.\n    edition_id : int or None, optional\n        The edition ID of the book, by default None.\n    limit : int, optional\n        The number of users to retrieve per page, by default 500.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[int]\n        A paginated list of user IDs.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n    [1, 2, 3]\n    \"\"\"\n    url = f\"{self.base_url}/livro/leitores/{status.value}/{book_id}/limit:{limit}/page:{page}\"\n    if edition_id:\n        url += f\"/edition:{edition_id}\"\n    logger.info(\n        \"Getting users for book_id: %s with status '%s' on page %s\",\n        book_id,\n        status.value,\n        page,\n    )\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        users_id = extract_user_ids_from_html(soup)\n        next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n        logger.error(f\"Failed to parse users by status: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse users by status.\") from e\n    except Exception as e:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred during user status fetching: %s\",\n            e,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during user status fetching.\") from e\n    logger.info(\n        \"Found %s users on page %s.\",\n        len(users_id),\n        page,\n    )\n    return Pagination[int](\n        results=users_id,\n        limit=limit,\n        page=page,\n        total=len(users_id),\n        has_next_page=next_page_link is not None,\n    )\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.search","title":"<code>search(query, search_by=BookSearch.TITLE, page=1)</code>","text":"<p>Searches for books by query and type.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query string.</p> required <code>search_by</code> <code>BookSearch</code> <p>The type of search (title, author, etc.), by default <code>BookSearch.TITLE</code>.</p> <code>TITLE</code> <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookSearchResult]</code> <p>A paginated list of search results.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"Duna\").results[0].title\n'Duna'\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def search(\n    self,\n    query: str,\n    search_by: BookSearch = BookSearch.TITLE,\n    page: int = 1,\n) -&gt; Pagination[BookSearchResult]:\n    \"\"\"\n    Searches for books by query and type.\n\n    Parameters\n    ----------\n    query : str\n        The search query string.\n    search_by : BookSearch, optional\n        The type of search (title, author, etc.), by default\n        ``BookSearch.TITLE``.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookSearchResult]\n        A paginated list of search results.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"Duna\").results[0].title\n    'Duna'\n    \"\"\"\n    url = f\"{self.base_url}/livro/lista/busca:{query}/tipo:{search_by.value}/mpage:{page}\"\n    logger.info(f\"Searching for books with query: '{query}' on page {page}\")\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n\n        limit = 30\n        results = [\n            parse_search_result(book_div, self.base_url)\n            for book_div in safe_find_all(soup, \"div\", {\"class\": \"box_lista_busca_vertical\"})\n        ]\n        cleaned_results: list[BookSearchResult] = [i for i in results if i]\n\n        total_results = extract_total_results(soup)\n        next_page_link = True if page * limit &lt; total_results else False\n    except (AttributeError, ValueError, IndexError, TypeError) as e:  # pragma: no cover - defensive\n        logger.error(f\"Failed to parse book search results: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse book search results.\") from e\n    except Exception as e:  # pragma: no cover - unexpected\n        logger.error(\n            f\"An unexpected error occurred during book search: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during book search.\") from e\n\n    logger.info(\n        \"Found %s books on page %s, total %s results.\",\n        len(results),\n        page,\n        total_results,\n    )\n    return Pagination[BookSearchResult](\n        results=cleaned_results,\n        limit=30,\n        page=page,\n        total=total_results,\n        has_next_page=next_page_link,\n    )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and the project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial structure for the changelog.</li> <li>AuthorService for searching authors.</li> <li>Example script demonstrating AuthorService usage.</li> <li>Documentation for pagination and asynchronous usage examples.</li> <li>List of stable public API exports.</li> <li>Introduced <code>AuthenticatedService</code> base class to centralize login validation for services requiring authentication.</li> <li>Pre-commit configuration for Ruff, formatting and tests.</li> <li>Security policy describing vulnerability reporting and secret management.</li> <li>Automated GitHub Pages workflow to build and deploy documentation.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Avoided <code>httpx</code> deprecation warning when posting raw bytes or text.</li> <li>Updated PyPI publish workflow to use the latest action release, resolving missing metadata errors.</li> <li>Installed <code>mkdocs-material</code> in the release workflow to resolve missing theme errors.</li> <li>Prevented release failures by skipping tag creation when the version tag already exists.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Removed the standalone lint workflow and moved Ruff earlier in the CI job.</li> <li>Added a dedicated step to install Ruff before running linting.</li> <li>Fixed installation command for Ruff to target the system environment.</li> <li>Restricted the release workflow to run only after the Bump Version workflow succeeds on the <code>main</code> branch.</li> </ul>"},{"location":"changelog/#010-2025-07-30","title":"[0.1.0] - 2025-07-30","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>Thank you for wanting to contribute to PySkoob! The following guidelines will help you open good issues and pull requests.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Search the existing issues to avoid duplicates.</li> <li>Provide clear steps to reproduce the problem and describe what you expected to happen.</li> <li>Include logs, stack traces and your environment information when applicable.</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository and create a new branch from <code>main</code>.</li> <li>Keep your changes focused on a single topic or feature.</li> <li>Write descriptive commit messages and link your PR to an open issue when possible.</li> <li>Make sure tests pass locally before submitting the PR.</li> </ol>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"<pre><code># Install uv (once)\n# pipx install uv\n\n# Create a virtual environment with uv\nuv venv .venv\nsource .venv/bin/activate\n\n# Install dependencies in editable mode\nuv pip install -e .[dev]\n\n# Install pre-commit hooks\npre-commit install\n\n# Run all checks\npre-commit run --all-files\n</code></pre> <p>Run <code>pre-commit run --all-files</code> to ensure formatting, linting and tests pass locally. The CI workflow runs the same hooks to verify submitted changes.</p> <p>Open your PR on GitHub and fill in a brief summary of your changes. A maintainer will review it as soon as possible.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Adhere to PEP 8 and keep lines under 140 characters.</li> <li>Run <code>ruff --fix</code> to format and lint the codebase.</li> <li>Provide type hints and docstrings for all public modules, classes, and functions.</li> </ul>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>This project follows the Conventional Commits specification.</p> <ul> <li>Use the structure <code>&lt;type&gt;: &lt;short description&gt;</code> in the imperative mood.</li> <li>Common types include <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>refactor</code>, <code>test</code>, and <code>chore</code>.</li> <li>Limit the first line to 72 characters and reference issues when relevant, e.g., <code>fix: handle edge case (#123)</code>.</li> </ul>"},{"location":"contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Review the coding standards and commit message format above before submitting your work.</li> <li>Add tests for any new functionality.</li> <li>Update documentation whenever behavior changes.</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>To build and preview the documentation locally:</p> <pre><code>uv pip install -e .[docs]\nmkdocs build --strict\nmkdocs serve\n</code></pre> <p>The build step validates links and outputs the site to the <code>site/</code> directory.</p>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>To publish a new version and deploy documentation:</p> <p>Ensure <code>PYPI_API_TOKEN</code> is stored in the repository secrets and GitHub Pages is enabled for the <code>gh-pages</code> branch before triggering the workflow.</p> <ol> <li>Trigger the Release workflow from the GitHub Actions tab.</li> <li>Choose the desired semantic version bump (<code>patch</code>, <code>minor</code>, or <code>major</code>).</li> <li>The workflow will bump the version, tag the commit, publish to PyPI, build the documentation, and push it to GitHub Pages.</li> </ol>"},{"location":"profile_service/","title":"Profile Service","text":"<p>The <code>SkoobProfileService</code> lets you modify your Skoob profile by labeling, shelving and rating books.</p>"},{"location":"profile_service/#example","title":"Example","text":"<pre><code>import os\nfrom pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookStatus\n\nwith SkoobClient() as client:\n    client.auth.login(\n        email=os.getenv(\"SKOOB_EMAIL\"),\n        password=os.getenv(\"SKOOB_PASSWORD\"),\n    )\n    client.profile.update_book_status(10, BookStatus.READ)\n</code></pre> <p>Profile management helpers for authenticated Skoob users.</p>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService","title":"<code>AsyncSkoobProfileService</code>","text":"<p>               Bases: <code>AsyncAuthenticatedService</code></p> <p>Asynchronous variant of :class:<code>SkoobProfileService</code>.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>class AsyncSkoobProfileService(AsyncAuthenticatedService):  # pragma: no cover - thin async wrapper\n    \"\"\"Asynchronous variant of :class:`SkoobProfileService`.\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient, auth_service: AsyncAuthService):\n        super().__init__(client, auth_service)\n\n    async def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n        \"\"\"Add a label to a book in the authenticated profile.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n        label : BookLabel\n            Label to apply to the book.\n\n        Returns\n        -------\n        bool\n            ``True`` if the operation succeeded.\n        \"\"\"\n\n        await self._validate_login()\n        url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    async def remove_book_label(self, edition_id: int) -&gt; bool:\n        \"\"\"Remove a label from a book in the authenticated profile.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n\n        Returns\n        -------\n        bool\n            ``True`` if the operation succeeded.\n        \"\"\"\n\n        await self._validate_login()\n        url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    async def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n        \"\"\"Update the user's status for a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n        status : BookStatus\n            New status to assign to the book.\n\n        Returns\n        -------\n        bool\n            ``True`` if the status update succeeded.\n        \"\"\"\n\n        await self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    async def remove_book_status(self, edition_id: int) -&gt; bool:\n        \"\"\"Remove the user's status for a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n\n        Returns\n        -------\n        bool\n            ``True`` if the status was removed successfully.\n        \"\"\"\n\n        await self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    async def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n        \"\"\"Move a book to a different bookshelf.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n        bookshelf : BookShelf\n            Target bookshelf.\n\n        Returns\n        -------\n        bool\n            ``True`` if the operation succeeded.\n        \"\"\"\n\n        await self._validate_login()\n        url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    async def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n        \"\"\"Rate a book in the authenticated profile.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition identifier.\n        ranking : float\n            Rating between 0 and 5.\n\n        Returns\n        -------\n        bool\n            ``True`` if the rating was saved.\n\n        Raises\n        ------\n        ValueError\n            If ``ranking`` is outside the 0\u20135 range.\n        RuntimeError\n            If Skoob rejects the rating.\n        \"\"\"\n\n        await self._validate_login()\n        if not (0 &lt;= ranking &lt;= 5):\n            raise ValueError(\"Rating must be between 0 and 5.\")\n        url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        if not response.json().get(\"success\"):\n            raise RuntimeError(\"Failed to rate the book.\")\n        return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.add_book_label","title":"<code>add_book_label(edition_id, label)</code>  <code>async</code>","text":"<p>Add a label to a book in the authenticated profile.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <code>label</code> <code>BookLabel</code> <p>Label to apply to the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the operation succeeded.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n    \"\"\"Add a label to a book in the authenticated profile.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n    label : BookLabel\n        Label to apply to the book.\n\n    Returns\n    -------\n    bool\n        ``True`` if the operation succeeded.\n    \"\"\"\n\n    await self._validate_login()\n    url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.change_book_shelf","title":"<code>change_book_shelf(edition_id, bookshelf)</code>  <code>async</code>","text":"<p>Move a book to a different bookshelf.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <code>bookshelf</code> <code>BookShelf</code> <p>Target bookshelf.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the operation succeeded.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n    \"\"\"Move a book to a different bookshelf.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n    bookshelf : BookShelf\n        Target bookshelf.\n\n    Returns\n    -------\n    bool\n        ``True`` if the operation succeeded.\n    \"\"\"\n\n    await self._validate_login()\n    url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.rate_book","title":"<code>rate_book(edition_id, ranking)</code>  <code>async</code>","text":"<p>Rate a book in the authenticated profile.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <code>ranking</code> <code>float</code> <p>Rating between 0 and 5.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the rating was saved.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>ranking</code> is outside the 0\u20135 range.</p> <code>RuntimeError</code> <p>If Skoob rejects the rating.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n    \"\"\"Rate a book in the authenticated profile.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n    ranking : float\n        Rating between 0 and 5.\n\n    Returns\n    -------\n    bool\n        ``True`` if the rating was saved.\n\n    Raises\n    ------\n    ValueError\n        If ``ranking`` is outside the 0\u20135 range.\n    RuntimeError\n        If Skoob rejects the rating.\n    \"\"\"\n\n    await self._validate_login()\n    if not (0 &lt;= ranking &lt;= 5):\n        raise ValueError(\"Rating must be between 0 and 5.\")\n    url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    if not response.json().get(\"success\"):\n        raise RuntimeError(\"Failed to rate the book.\")\n    return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.remove_book_label","title":"<code>remove_book_label(edition_id)</code>  <code>async</code>","text":"<p>Remove a label from a book in the authenticated profile.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the operation succeeded.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def remove_book_label(self, edition_id: int) -&gt; bool:\n    \"\"\"Remove a label from a book in the authenticated profile.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n\n    Returns\n    -------\n    bool\n        ``True`` if the operation succeeded.\n    \"\"\"\n\n    await self._validate_login()\n    url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.remove_book_status","title":"<code>remove_book_status(edition_id)</code>  <code>async</code>","text":"<p>Remove the user's status for a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the status was removed successfully.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def remove_book_status(self, edition_id: int) -&gt; bool:\n    \"\"\"Remove the user's status for a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n\n    Returns\n    -------\n    bool\n        ``True`` if the status was removed successfully.\n    \"\"\"\n\n    await self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.AsyncSkoobProfileService.update_book_status","title":"<code>update_book_status(edition_id, status)</code>  <code>async</code>","text":"<p>Update the user's status for a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition identifier.</p> required <code>status</code> <code>BookStatus</code> <p>New status to assign to the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the status update succeeded.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>async def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n    \"\"\"Update the user's status for a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition identifier.\n    status : BookStatus\n        New status to assign to the book.\n\n    Returns\n    -------\n    bool\n        ``True`` if the status update succeeded.\n    \"\"\"\n\n    await self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService","title":"<code>SkoobProfileService</code>","text":"<p>               Bases: <code>AuthenticatedService</code></p> <p>Perform profile-related actions such as labeling and rating books.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>class SkoobProfileService(AuthenticatedService):\n    \"\"\"Perform profile-related actions such as labeling and rating books.\"\"\"\n\n    def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n        \"\"\"Initialize the service with dependencies.\n\n        This service requires an authenticated session via\n        :class:`AuthService` and is typically used alongside\n        :class:`UserService` when manipulating the logged user's bookshelf\n        and other profile metadata.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n        auth_service : AuthService\n            The authentication service.\n        \"\"\"\n        super().__init__(client, auth_service)\n\n    def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n        \"\"\"\n        Adds a label to a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        label : BookLabel\n            The label to add.\n\n        Returns\n        -------\n        bool\n            True if the label was added successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def remove_book_label(self, edition_id: int) -&gt; bool:\n        \"\"\"\n        Removes a label from a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        bool\n            True if the label was removed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.remove_book_label(10)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n        \"\"\"\n        Updates the status of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        status : BookStatus\n            The new status for the book.\n\n        Returns\n        -------\n        bool\n            True if the status was updated successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def remove_book_status(self, edition_id: int) -&gt; bool:\n        \"\"\"\n        Removes the status of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        bool\n            True if the status was removed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.remove_book_status(10)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n        \"\"\"\n        Changes the bookshelf of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        bookshelf : BookShelf\n            The new bookshelf for the book.\n\n        Returns\n        -------\n        bool\n            True if the bookshelf was changed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n        \"\"\"\n        Rates a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        ranking : float\n            The rating to give to the book (from 0 to 5).\n\n        Returns\n        -------\n        bool\n            True if the book was rated successfully.\n\n        Raises\n        ------\n        ValueError\n            If the rating is not between 0 and 5.\n        RuntimeError\n            If it fails to rate the book.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.rate_book(10, 4.5)\n        True\n        \"\"\"\n        self._validate_login()\n        if not (0 &lt;= ranking &lt;= 5):\n            raise ValueError(\"Rating must be between 0 and 5.\")\n\n        url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        if not response.json().get(\"success\"):\n            raise RuntimeError(\"Failed to rate the book.\")\n        return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.__init__","title":"<code>__init__(client, auth_service)</code>","text":"<p>Initialize the service with dependencies.</p> <p>This service requires an authenticated session via :class:<code>AuthService</code> and is typically used alongside :class:<code>UserService</code> when manipulating the logged user's bookshelf and other profile metadata.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <code>auth_service</code> <code>AuthService</code> <p>The authentication service.</p> required Source code in <code>pyskoob/profile.py</code> <pre><code>def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n    \"\"\"Initialize the service with dependencies.\n\n    This service requires an authenticated session via\n    :class:`AuthService` and is typically used alongside\n    :class:`UserService` when manipulating the logged user's bookshelf\n    and other profile metadata.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n    auth_service : AuthService\n        The authentication service.\n    \"\"\"\n    super().__init__(client, auth_service)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.add_book_label","title":"<code>add_book_label(edition_id, label)</code>","text":"<p>Adds a label to a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>label</code> <code>BookLabel</code> <p>The label to add.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was added successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n    \"\"\"\n    Adds a label to a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    label : BookLabel\n        The label to add.\n\n    Returns\n    -------\n    bool\n        True if the label was added successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.change_book_shelf","title":"<code>change_book_shelf(edition_id, bookshelf)</code>","text":"<p>Changes the bookshelf of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>bookshelf</code> <code>BookShelf</code> <p>The new bookshelf for the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the bookshelf was changed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n    \"\"\"\n    Changes the bookshelf of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    bookshelf : BookShelf\n        The new bookshelf for the book.\n\n    Returns\n    -------\n    bool\n        True if the bookshelf was changed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.rate_book","title":"<code>rate_book(edition_id, ranking)</code>","text":"<p>Rates a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>ranking</code> <code>float</code> <p>The rating to give to the book (from 0 to 5).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the book was rated successfully.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the rating is not between 0 and 5.</p> <code>RuntimeError</code> <p>If it fails to rate the book.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.rate_book(10, 4.5)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n    \"\"\"\n    Rates a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    ranking : float\n        The rating to give to the book (from 0 to 5).\n\n    Returns\n    -------\n    bool\n        True if the book was rated successfully.\n\n    Raises\n    ------\n    ValueError\n        If the rating is not between 0 and 5.\n    RuntimeError\n        If it fails to rate the book.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.rate_book(10, 4.5)\n    True\n    \"\"\"\n    self._validate_login()\n    if not (0 &lt;= ranking &lt;= 5):\n        raise ValueError(\"Rating must be between 0 and 5.\")\n\n    url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    if not response.json().get(\"success\"):\n        raise RuntimeError(\"Failed to rate the book.\")\n    return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.remove_book_label","title":"<code>remove_book_label(edition_id)</code>","text":"<p>Removes a label from a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was removed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.remove_book_label(10)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def remove_book_label(self, edition_id: int) -&gt; bool:\n    \"\"\"\n    Removes a label from a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    bool\n        True if the label was removed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.remove_book_label(10)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.remove_book_status","title":"<code>remove_book_status(edition_id)</code>","text":"<p>Removes the status of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the status was removed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.remove_book_status(10)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def remove_book_status(self, edition_id: int) -&gt; bool:\n    \"\"\"\n    Removes the status of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    bool\n        True if the status was removed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.remove_book_status(10)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.update_book_status","title":"<code>update_book_status(edition_id, status)</code>","text":"<p>Updates the status of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>status</code> <code>BookStatus</code> <p>The new status for the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the status was updated successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n    \"\"\"\n    Updates the status of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    status : BookStatus\n        The new status for the book.\n\n    Returns\n    -------\n    bool\n        True if the status was updated successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"publishers_service/","title":"Publisher Service","text":"<p>The <code>PublisherService</code> fetches information about publishers and their releases on Skoob.</p>"},{"location":"publishers_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    publisher = client.publishers.get_by_id(21)  # replace with a real id\n    print(publisher.name)\n</code></pre> <p>Retrieve publisher information, books and authors from Skoob.</p>"},{"location":"publishers_service/#pyskoob.publishers.AsyncPublisherService","title":"<code>AsyncPublisherService</code>","text":"<p>               Bases: <code>AsyncBaseSkoobService</code></p> <p>Asynchronous variant of :class:<code>PublisherService</code>.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>class AsyncPublisherService(AsyncBaseSkoobService):  # pragma: no cover - thin async wrapper\n    \"\"\"Asynchronous variant of :class:`PublisherService`.\"\"\"\n\n    def __init__(self, client: AsyncHTTPClient):\n        super().__init__(client)\n\n    async def get_by_id(self, publisher_id: int) -&gt; Publisher:\n        \"\"\"Retrieve detailed information about a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n\n        Returns\n        -------\n        Publisher\n            Structured publisher information including stats and releases.\n        \"\"\"\n\n        url = f\"{self.base_url}/editora/{publisher_id}\"\n        logger.info(\"Fetching publisher page: %s\", url)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n            description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n            site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n            website = get_tag_attr(site_link, \"href\")\n            stats = parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n            releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n            releases = [parse_book(div, self.base_url) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n            return Publisher(\n                id=publisher_id,\n                name=name,\n                description=description,\n                website=website,\n                stats=stats,\n                last_releases=releases,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher page.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher page: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n\n    async def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n        \"\"\"Retrieve authors associated with a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            Pagination page, by default ``1``.\n\n        Returns\n        -------\n        Pagination[PublisherAuthor]\n            Paginated list of authors published by the publisher.\n        \"\"\"\n\n        url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher authors: %s\", url)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            authors = [parse_author(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=authors,\n                limit=len(authors),\n                page=page,\n                total=len(authors),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher authors.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher authors: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n\n    async def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n        \"\"\"Retrieve books published by a given publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            Pagination page, by default ``1``.\n\n        Returns\n        -------\n        Pagination[PublisherItem]\n            Paginated list of books released by the publisher.\n        \"\"\"\n\n        url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher books: %s\", url)\n        try:\n            response = await self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            books = [parse_book(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=books,\n                limit=len(books),\n                page=page,\n                total=len(books),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher books.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher books: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.AsyncPublisherService.get_authors","title":"<code>get_authors(publisher_id, page=1)</code>  <code>async</code>","text":"<p>Retrieve authors associated with a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>Pagination page, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherAuthor]</code> <p>Paginated list of authors published by the publisher.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>async def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n    \"\"\"Retrieve authors associated with a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        Pagination page, by default ``1``.\n\n    Returns\n    -------\n    Pagination[PublisherAuthor]\n        Paginated list of authors published by the publisher.\n    \"\"\"\n\n    url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher authors: %s\", url)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        authors = [parse_author(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=authors,\n            limit=len(authors),\n            page=page,\n            total=len(authors),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher authors.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher authors: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.AsyncPublisherService.get_books","title":"<code>get_books(publisher_id, page=1)</code>  <code>async</code>","text":"<p>Retrieve books published by a given publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>Pagination page, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherItem]</code> <p>Paginated list of books released by the publisher.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>async def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n    \"\"\"Retrieve books published by a given publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        Pagination page, by default ``1``.\n\n    Returns\n    -------\n    Pagination[PublisherItem]\n        Paginated list of books released by the publisher.\n    \"\"\"\n\n    url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher books: %s\", url)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        books = [parse_book(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=books,\n            limit=len(books),\n            page=page,\n            total=len(books),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher books.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher books: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.AsyncPublisherService.get_by_id","title":"<code>get_by_id(publisher_id)</code>  <code>async</code>","text":"<p>Retrieve detailed information about a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <p>Returns:</p> Type Description <code>Publisher</code> <p>Structured publisher information including stats and releases.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>async def get_by_id(self, publisher_id: int) -&gt; Publisher:\n    \"\"\"Retrieve detailed information about a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n\n    Returns\n    -------\n    Publisher\n        Structured publisher information including stats and releases.\n    \"\"\"\n\n    url = f\"{self.base_url}/editora/{publisher_id}\"\n    logger.info(\"Fetching publisher page: %s\", url)\n    try:\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n        description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n        site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n        website = get_tag_attr(site_link, \"href\")\n        stats = parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n        releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n        releases = [parse_book(div, self.base_url) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n        return Publisher(\n            id=publisher_id,\n            name=name,\n            description=description,\n            website=website,\n            stats=stats,\n            last_releases=releases,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher page.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher page: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService","title":"<code>PublisherService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving publishers.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>class PublisherService(BaseSkoobService):\n    \"\"\"High level operations for retrieving publishers.\"\"\"\n\n    def get_by_id(self, publisher_id: int) -&gt; Publisher:\n        \"\"\"Retrieve detailed information about a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n\n        Returns\n        -------\n        Publisher\n            An object containing information about the publisher, including\n            statistics and recently released books.\n\n        Raises\n        ------\n        ParsingError\n            If the expected elements cannot be parsed from the page.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).name\n        'Editora Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/{publisher_id}\"\n        logger.info(\"Fetching publisher page: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n            description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n            site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n            website = get_tag_attr(site_link, \"href\")\n            stats = parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n            releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n            releases = [parse_book(div, self.base_url) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n            return Publisher(\n                id=publisher_id,\n                name=name,\n                description=description,\n                website=website,\n                stats=stats,\n                last_releases=releases,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher page.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher page: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n\n    def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n        \"\"\"Retrieve authors associated with a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            The pagination page to retrieve, by default 1.\n\n        Returns\n        -------\n        Pagination[PublisherAuthor]\n            A paginated list of authors published by the publisher.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure for authors cannot be parsed.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_authors(1).results[0].name\n        'Autor Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher authors: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            authors = [parse_author(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=authors,\n                limit=len(authors),\n                page=page,\n                total=len(authors),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher authors.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher authors: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n\n    def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n        \"\"\"Retrieve books published by the publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            The pagination page to retrieve, by default 1.\n\n        Returns\n        -------\n        Pagination[PublisherItem]\n            A paginated list of books released by the publisher.\n\n        Raises\n        ------\n        ParsingError\n            If book elements cannot be parsed from the page.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_books(1).results[0].title\n        'Livro Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher books: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            books = [parse_book(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=books,\n                limit=len(books),\n                page=page,\n                total=len(books),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n            logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher books.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher books: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_authors","title":"<code>get_authors(publisher_id, page=1)</code>","text":"<p>Retrieve authors associated with a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>The pagination page to retrieve, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherAuthor]</code> <p>A paginated list of authors published by the publisher.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure for authors cannot be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_authors(1).results[0].name\n'Autor Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n    \"\"\"Retrieve authors associated with a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        The pagination page to retrieve, by default 1.\n\n    Returns\n    -------\n    Pagination[PublisherAuthor]\n        A paginated list of authors published by the publisher.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure for authors cannot be parsed.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_authors(1).results[0].name\n    'Autor Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher authors: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        authors = [parse_author(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=authors,\n            limit=len(authors),\n            page=page,\n            total=len(authors),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher authors.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher authors: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_books","title":"<code>get_books(publisher_id, page=1)</code>","text":"<p>Retrieve books published by the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>The pagination page to retrieve, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherItem]</code> <p>A paginated list of books released by the publisher.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If book elements cannot be parsed from the page.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_books(1).results[0].title\n'Livro Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n    \"\"\"Retrieve books published by the publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        The pagination page to retrieve, by default 1.\n\n    Returns\n    -------\n    Pagination[PublisherItem]\n        A paginated list of books released by the publisher.\n\n    Raises\n    ------\n    ParsingError\n        If book elements cannot be parsed from the page.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_books(1).results[0].title\n    'Livro Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher books: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        books = [parse_book(div, self.base_url) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=books,\n            limit=len(books),\n            page=page,\n            total=len(books),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher books.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher books: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_by_id","title":"<code>get_by_id(publisher_id)</code>","text":"<p>Retrieve detailed information about a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <p>Returns:</p> Type Description <code>Publisher</code> <p>An object containing information about the publisher, including statistics and recently released books.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the expected elements cannot be parsed from the page.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).name\n'Editora Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_by_id(self, publisher_id: int) -&gt; Publisher:\n    \"\"\"Retrieve detailed information about a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n\n    Returns\n    -------\n    Publisher\n        An object containing information about the publisher, including\n        statistics and recently released books.\n\n    Raises\n    ------\n    ParsingError\n        If the expected elements cannot be parsed from the page.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).name\n    'Editora Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/{publisher_id}\"\n    logger.info(\"Fetching publisher page: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n        description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n        site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n        website = get_tag_attr(site_link, \"href\")\n        stats = parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n        releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n        releases = [parse_book(div, self.base_url) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n        return Publisher(\n            id=publisher_id,\n            name=name,\n            description=description,\n            website=website,\n            stats=stats,\n            last_releases=releases,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:  # pragma: no cover - defensive\n        logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher page.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher page: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n</code></pre>"},{"location":"stable_api/","title":"Stable Public API","text":"<p>The following classes and functions are considered stable. They are re-exported from the :mod:<code>pyskoob</code> package and will only change with a deprecation period. You can import them directly from the package root:</p> <pre><code>from pyskoob import SkoobClient, HttpxSyncClient\n</code></pre> <ul> <li><code>SkoobClient</code></li> <li><code>AuthService</code></li> <li><code>BookService</code></li> <li><code>AuthorService</code></li> <li><code>UserService</code></li> <li><code>SkoobProfileService</code></li> <li><code>PublisherService</code></li> <li><code>HttpxSyncClient</code></li> <li><code>HttpxAsyncClient</code></li> </ul> <p>Anything not listed above should be treated as internal and may change without notice.</p>"},{"location":"users_service/","title":"Users Service","text":"<p>The <code>UserService</code> searches and retrieves Skoob user profiles.</p>"},{"location":"users_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    # TIP: use environment variables or a secrets manager instead of hard-coding credentials\n    client.auth.login(email=\"you@example.com\", password=\"secret\")\n    results = client.users.search(\"victor\")\n    for user in results.results:\n        print(user.name, user.id)\n</code></pre> <p>Services for retrieving and manipulating Skoob user data.</p>"},{"location":"users_service/#pyskoob.users.AsyncUserService","title":"<code>AsyncUserService</code>","text":"<p>               Bases: <code>AsyncAuthenticatedService</code></p> <p>Asynchronous variant of :class:<code>UserService</code>.</p> <p>Fetch user profiles, books and friends from Skoob asynchronously.</p> <p>The service depends on :class:<code>AsyncAuthService</code> to validate the current session before performing operations that require authentication such as retrieving your own profile or editing bookshelf information.</p> Source code in <code>pyskoob/users.py</code> <pre><code>class AsyncUserService(AsyncAuthenticatedService):  # pragma: no cover - thin async wrapper\n    \"\"\"Asynchronous variant of :class:`UserService`.\n\n    Fetch user profiles, books and friends from Skoob asynchronously.\n\n    The service depends on :class:`AsyncAuthService` to validate the current\n    session before performing operations that require authentication such as\n    retrieving your own profile or editing bookshelf information.\n    \"\"\"\n\n    def __init__(self, client: AsyncHTTPClient, auth_service: AsyncAuthService):\n        super().__init__(client, auth_service)\n\n    async def get_by_id(self, user_id: int) -&gt; User:\n        \"\"\"Retrieve a user by their ID asynchronously.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        User\n            The user's information.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the user with the given ID is not found.\n        \"\"\"\n        await self._validate_login()\n        logger.info(f\"Getting user by id: {user_id}\")\n        url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.warning(f\"User with ID {user_id} not found.\")\n            raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]\n        user = User.model_validate(user_data)\n        logger.info(f\"Successfully retrieved user: '{user.name}'\")\n        return user\n\n    async def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n        \"\"\"Retrieve a user's relations (friends, followers, following).\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        relation : UsersRelation\n            The type of relation to retrieve.\n        page : int, optional\n            The page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[int]\n            A paginated list of user IDs.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n        \"\"\"\n        await self._validate_login()\n        url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n        logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        try:\n            users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n            users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n            next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError) as e:\n            logger.error(f\"Failed to parse user relations: {e}\")\n            raise ParsingError(\"Failed to parse user relations.\") from e\n        logger.info(f\"Found {len(users_id)} users on page {page}.\")\n        return Pagination(\n            results=users_id,\n            limit=100,\n            page=page,\n            total=len(users_id),\n            has_next_page=bool(next_page_link),\n        )\n\n    async def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n        \"\"\"Retrieve reviews made by a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        page : int, optional\n            The page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[BookReview]\n            A paginated list of book reviews.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n        \"\"\"\n        await self._validate_login()\n        url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n        logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n        response = await self.client.get(url)\n        response.raise_for_status()\n        user_reviews: list[BookReview] = []\n        soup = self.parse_html(response.text)\n        try:\n            reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n            for review_elem in reviews_html:\n                review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n                book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n                book_url = get_tag_attr(book_anchor, \"href\")\n                book_id = int(get_book_id_from_url(book_url))\n                edition_id = int(get_book_edition_id_from_url(book_url))\n                star_rating = safe_find(review_elem, \"star-rating\")\n                rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n                comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n                date_str = get_tag_text(safe_find(comment, \"span\"))\n                date = None\n                if date_str:\n                    try:\n                        date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                    except ValueError:\n                        date = None\n                review_text = \"\"\n                if comment:\n                    span = safe_find(comment, \"span\")\n                    if span:\n                        siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                        review_text = \"\\n\".join(siblings).strip()\n                user_reviews.append(\n                    BookReview(\n                        review_id=review_id,\n                        book_id=book_id,\n                        edition_id=edition_id,\n                        user_id=user_id,\n                        rating=rating,\n                        review_text=review_text,\n                        reviewed_at=date,\n                    )\n                )\n            next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n        except (AttributeError, ValueError, IndexError) as e:\n            logger.error(f\"Failed to parse user reviews: {e}\")\n            raise ParsingError(\"Failed to parse user reviews.\") from e\n        logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n        return Pagination(\n            results=user_reviews,\n            limit=50,\n            page=page,\n            total=len(user_reviews),\n            has_next_page=bool(next_page_link),\n        )\n\n    async def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n        \"\"\"Retrieve reading statistics for a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        UserReadStats\n            The user's reading statistics.\n        \"\"\"\n        await self._validate_login()\n        logger.info(f\"Getting read stats for user_id: {user_id}\")\n        url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json().get(\"response\", {})\n        stats = UserReadStats(\n            user_id=user_id,\n            year=json_data.get(\"ano\"),\n            books_read=json_data.get(\"lido\"),\n            pages_read=json_data.get(\"paginas_lidas\"),\n            total_pages=json_data.get(\"paginas_total\"),\n            percent_complete=json_data.get(\"percentual_lido\"),\n            books_total=json_data.get(\"total\"),\n            reading_speed=json_data.get(\"velocidade_dia\"),\n            ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n        )\n        logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n        return stats\n\n    async def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n        \"\"\"Retrieve a user's bookcase.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        bookcase_option : BookcaseOption\n            The type of bookcase to retrieve.\n        page : int, optional\n            The page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[UserBook]\n            A paginated list of books in the user's bookcase.\n        \"\"\"\n        await self._validate_login()\n        url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n        logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n        response = await self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json()\n        next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n        results = []\n        for r in json_data.get(\"response\", []):\n            edicao = r.get(\"edicao\", {})\n            results.append(\n                UserBook(\n                    user_id=user_id,\n                    book_id=edicao.get(\"livro_id\"),\n                    edition_id=edicao.get(\"id\"),\n                    rating=r.get(\"ranking\"),\n                    is_favorite=r.get(\"favorito\"),\n                    is_wishlist=r.get(\"desejado\"),\n                    is_tradable=r.get(\"troco\"),\n                    is_owned=r.get(\"tenho\"),\n                    is_loaned=r.get(\"emprestei\"),\n                    reading_goal_year=r.get(\"meta\"),\n                    pages_read=r.get(\"paginas_lidas\"),\n                )\n            )\n        logger.info(f\"Found {len(results)} books on page {page}.\")\n        return Pagination(\n            limit=100,\n            results=results,\n            total=len(results),\n            has_next_page=bool(next_page),\n            page=page,\n        )\n\n    async def search(\n        self,\n        query: str,\n        gender: UserGender | None = None,\n        state: BrazilianState | None = None,\n        page: int = 1,\n        limit: int = 100,\n    ) -&gt; Pagination[UserSearch]:\n        \"\"\"Search for users on Skoob.\n\n        Parameters\n        ----------\n        query : str\n            The search query for usernames or names.\n        gender : UserGender, optional\n            Optional gender filter (M/F), by default ``None``.\n        state : BrazilianState, optional\n            Optional state filter, by default ``None``.\n        page : int, optional\n            Page number to fetch, by default ``1``.\n        limit : int, optional\n            Number of users per page, by default ``100``.\n\n        Returns\n        -------\n        Pagination[UserSearch]\n            A paginated list of users matching the criteria.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure is invalid or parsing fails.\n        \"\"\"\n        await self._validate_login()\n        url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n        if gender:\n            url += f\"/sexo:{gender.value}\"\n        if state:\n            url += f\"/uf:{state.value}\"\n        response = await self.client.get(url)\n        response.raise_for_status()\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        try:\n            user_divs = safe_find_all(\n                soup,\n                \"div\",\n                attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n            )\n            results: list[UserSearch] = []\n            for div in user_divs:\n                anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n                if not anchor:\n                    continue\n                href = get_tag_attr(anchor, \"href\")\n                full_url = f\"{self.base_url}{href}\"\n                match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n                if not match:\n                    continue\n                user_id = int(match.group(1))\n                username = match.group(2)\n                name = get_tag_text(anchor)\n                results.append(\n                    UserSearch(\n                        id=user_id,\n                        username=username,\n                        name=name,\n                        url=full_url,\n                    )\n                )\n            total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n            total_text = get_tag_text(total_tag)\n            total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n            next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n            has_next = next_page is not None\n            return Pagination[UserSearch](\n                results=results,\n                page=page,\n                total=total,\n                limit=limit,\n                has_next_page=has_next,\n            )\n        except Exception as e:  # pragma: no cover - unlikely\n            raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.get_bookcase","title":"<code>get_bookcase(user_id, bookcase_option, page=1)</code>  <code>async</code>","text":"<p>Retrieve a user's bookcase.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>bookcase_option</code> <code>BookcaseOption</code> <p>The type of bookcase to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[UserBook]</code> <p>A paginated list of books in the user's bookcase.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n    \"\"\"Retrieve a user's bookcase.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    bookcase_option : BookcaseOption\n        The type of bookcase to retrieve.\n    page : int, optional\n        The page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[UserBook]\n        A paginated list of books in the user's bookcase.\n    \"\"\"\n    await self._validate_login()\n    url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n    logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n    response = await self.client.get(url)\n    response.raise_for_status()\n    json_data = response.json()\n    next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n    results = []\n    for r in json_data.get(\"response\", []):\n        edicao = r.get(\"edicao\", {})\n        results.append(\n            UserBook(\n                user_id=user_id,\n                book_id=edicao.get(\"livro_id\"),\n                edition_id=edicao.get(\"id\"),\n                rating=r.get(\"ranking\"),\n                is_favorite=r.get(\"favorito\"),\n                is_wishlist=r.get(\"desejado\"),\n                is_tradable=r.get(\"troco\"),\n                is_owned=r.get(\"tenho\"),\n                is_loaned=r.get(\"emprestei\"),\n                reading_goal_year=r.get(\"meta\"),\n                pages_read=r.get(\"paginas_lidas\"),\n            )\n        )\n    logger.info(f\"Found {len(results)} books on page {page}.\")\n    return Pagination(\n        limit=100,\n        results=results,\n        total=len(results),\n        has_next_page=bool(next_page),\n        page=page,\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.get_by_id","title":"<code>get_by_id(user_id)</code>  <code>async</code>","text":"<p>Retrieve a user by their ID asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The user's information.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the user with the given ID is not found.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def get_by_id(self, user_id: int) -&gt; User:\n    \"\"\"Retrieve a user by their ID asynchronously.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    User\n        The user's information.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the user with the given ID is not found.\n    \"\"\"\n    await self._validate_login()\n    logger.info(f\"Getting user by id: {user_id}\")\n    url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.warning(f\"User with ID {user_id} not found.\")\n        raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]\n    user = User.model_validate(user_data)\n    logger.info(f\"Successfully retrieved user: '{user.name}'\")\n    return user\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.get_read_stats","title":"<code>get_read_stats(user_id)</code>  <code>async</code>","text":"<p>Retrieve reading statistics for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>UserReadStats</code> <p>The user's reading statistics.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n    \"\"\"Retrieve reading statistics for a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    UserReadStats\n        The user's reading statistics.\n    \"\"\"\n    await self._validate_login()\n    logger.info(f\"Getting read stats for user_id: {user_id}\")\n    url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    json_data = response.json().get(\"response\", {})\n    stats = UserReadStats(\n        user_id=user_id,\n        year=json_data.get(\"ano\"),\n        books_read=json_data.get(\"lido\"),\n        pages_read=json_data.get(\"paginas_lidas\"),\n        total_pages=json_data.get(\"paginas_total\"),\n        percent_complete=json_data.get(\"percentual_lido\"),\n        books_total=json_data.get(\"total\"),\n        reading_speed=json_data.get(\"velocidade_dia\"),\n        ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n    )\n    logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n    return stats\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.get_relations","title":"<code>get_relations(user_id, relation, page=1)</code>  <code>async</code>","text":"<p>Retrieve a user's relations (friends, followers, following).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>relation</code> <code>UsersRelation</code> <p>The type of relation to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[int]</code> <p>A paginated list of user IDs.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n    \"\"\"Retrieve a user's relations (friends, followers, following).\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    relation : UsersRelation\n        The type of relation to retrieve.\n    page : int, optional\n        The page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[int]\n        A paginated list of user IDs.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n    \"\"\"\n    await self._validate_login()\n    url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n    logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n    response = await self.client.get(url)\n    response.raise_for_status()\n    soup = self.parse_html(response.text)\n    try:\n        users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n        users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n        next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError) as e:\n        logger.error(f\"Failed to parse user relations: {e}\")\n        raise ParsingError(\"Failed to parse user relations.\") from e\n    logger.info(f\"Found {len(users_id)} users on page {page}.\")\n    return Pagination(\n        results=users_id,\n        limit=100,\n        page=page,\n        total=len(users_id),\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.get_reviews","title":"<code>get_reviews(user_id, page=1)</code>  <code>async</code>","text":"<p>Retrieve reviews made by a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookReview]</code> <p>A paginated list of book reviews.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n    \"\"\"Retrieve reviews made by a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    page : int, optional\n        The page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[BookReview]\n        A paginated list of book reviews.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n    \"\"\"\n    await self._validate_login()\n    url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n    logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n    response = await self.client.get(url)\n    response.raise_for_status()\n    user_reviews: list[BookReview] = []\n    soup = self.parse_html(response.text)\n    try:\n        reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n        for review_elem in reviews_html:\n            review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n            book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n            book_url = get_tag_attr(book_anchor, \"href\")\n            book_id = int(get_book_id_from_url(book_url))\n            edition_id = int(get_book_edition_id_from_url(book_url))\n            star_rating = safe_find(review_elem, \"star-rating\")\n            rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n            comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n            date_str = get_tag_text(safe_find(comment, \"span\"))\n            date = None\n            if date_str:\n                try:\n                    date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                except ValueError:\n                    date = None\n            review_text = \"\"\n            if comment:\n                span = safe_find(comment, \"span\")\n                if span:\n                    siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                    review_text = \"\\n\".join(siblings).strip()\n            user_reviews.append(\n                BookReview(\n                    review_id=review_id,\n                    book_id=book_id,\n                    edition_id=edition_id,\n                    user_id=user_id,\n                    rating=rating,\n                    review_text=review_text,\n                    reviewed_at=date,\n                )\n            )\n        next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n    except (AttributeError, ValueError, IndexError) as e:\n        logger.error(f\"Failed to parse user reviews: {e}\")\n        raise ParsingError(\"Failed to parse user reviews.\") from e\n    logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n    return Pagination(\n        results=user_reviews,\n        limit=50,\n        page=page,\n        total=len(user_reviews),\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.AsyncUserService.search","title":"<code>search(query, gender=None, state=None, page=1, limit=100)</code>  <code>async</code>","text":"<p>Search for users on Skoob.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query for usernames or names.</p> required <code>gender</code> <code>UserGender</code> <p>Optional gender filter (M/F), by default <code>None</code>.</p> <code>None</code> <code>state</code> <code>BrazilianState</code> <p>Optional state filter, by default <code>None</code>.</p> <code>None</code> <code>page</code> <code>int</code> <p>Page number to fetch, by default <code>1</code>.</p> <code>1</code> <code>limit</code> <code>int</code> <p>Number of users per page, by default <code>100</code>.</p> <code>100</code> <p>Returns:</p> Type Description <code>Pagination[UserSearch]</code> <p>A paginated list of users matching the criteria.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure is invalid or parsing fails.</p> Source code in <code>pyskoob/users.py</code> <pre><code>async def search(\n    self,\n    query: str,\n    gender: UserGender | None = None,\n    state: BrazilianState | None = None,\n    page: int = 1,\n    limit: int = 100,\n) -&gt; Pagination[UserSearch]:\n    \"\"\"Search for users on Skoob.\n\n    Parameters\n    ----------\n    query : str\n        The search query for usernames or names.\n    gender : UserGender, optional\n        Optional gender filter (M/F), by default ``None``.\n    state : BrazilianState, optional\n        Optional state filter, by default ``None``.\n    page : int, optional\n        Page number to fetch, by default ``1``.\n    limit : int, optional\n        Number of users per page, by default ``100``.\n\n    Returns\n    -------\n    Pagination[UserSearch]\n        A paginated list of users matching the criteria.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure is invalid or parsing fails.\n    \"\"\"\n    await self._validate_login()\n    url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n    if gender:\n        url += f\"/sexo:{gender.value}\"\n    if state:\n        url += f\"/uf:{state.value}\"\n    response = await self.client.get(url)\n    response.raise_for_status()\n    soup = BeautifulSoup(response.text, \"html.parser\")\n    try:\n        user_divs = safe_find_all(\n            soup,\n            \"div\",\n            attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n        )\n        results: list[UserSearch] = []\n        for div in user_divs:\n            anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n            if not anchor:\n                continue\n            href = get_tag_attr(anchor, \"href\")\n            full_url = f\"{self.base_url}{href}\"\n            match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n            if not match:\n                continue\n            user_id = int(match.group(1))\n            username = match.group(2)\n            name = get_tag_text(anchor)\n            results.append(\n                UserSearch(\n                    id=user_id,\n                    username=username,\n                    name=name,\n                    url=full_url,\n                )\n            )\n        total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n        total_text = get_tag_text(total_tag)\n        total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n        next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        has_next = next_page is not None\n        return Pagination[UserSearch](\n            results=results,\n            page=page,\n            total=total,\n            limit=limit,\n            has_next_page=has_next,\n        )\n    except Exception as e:  # pragma: no cover - unlikely\n        raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService","title":"<code>UserService</code>","text":"<p>               Bases: <code>AuthenticatedService</code></p> <p>Fetch user profiles, books and friends from Skoob.</p> Source code in <code>pyskoob/users.py</code> <pre><code>class UserService(AuthenticatedService):\n    \"\"\"Fetch user profiles, books and friends from Skoob.\"\"\"\n\n    def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n        \"\"\"Initialize the service with dependencies.\n\n        The service depends on :class:`AuthService` to validate the current\n        session before performing operations that require authentication such\n        as retrieving your own profile or editing bookshelf information.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n        auth_service : AuthService\n            The authentication service.\n        \"\"\"\n        super().__init__(client, auth_service)\n\n    def get_by_id(self, user_id: int) -&gt; User:\n        \"\"\"\n        Retrieves a user by their ID.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        User\n            The user's information.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the user with the given ID is not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).name\n        'Example'\n        \"\"\"\n        self._validate_login()\n        logger.info(f\"Getting user by id: {user_id}\")\n        url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.warning(f\"User with ID {user_id} not found.\")\n            raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n        user = User.model_validate(user_data)\n        logger.info(f\"Successfully retrieved user: '{user.name}'\")\n        return user\n\n    def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n        \"\"\"\n        Retrieves a user's relations (friends, followers, following).\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        relation : UsersRelation\n            The type of relation to retrieve.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[int]\n            A paginated list of user IDs.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n        [2, 3]\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n        logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        soup = self.parse_html(response.text)\n        try:\n            users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n            users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n            next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError) as e:  # pragma: no cover - defensive\n            logger.error(f\"Failed to parse user relations: {e}\")\n            raise ParsingError(\"Failed to parse user relations.\") from e\n\n        logger.info(f\"Found {len(users_id)} users on page {page}.\")\n        return Pagination(\n            results=users_id,\n            limit=100,\n            page=page,\n            total=len(users_id),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page_link),\n        )\n\n    def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n        \"\"\"\n        Retrieves reviews made by a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookReview]\n            A paginated list of book reviews.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n        logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        user_reviews: list[BookReview] = []\n        soup = self.parse_html(response.text)\n        try:\n            reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n            for review_elem in reviews_html:\n                review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n                book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n                book_url = get_tag_attr(book_anchor, \"href\")\n                book_id = int(get_book_id_from_url(book_url))\n                edition_id = int(get_book_edition_id_from_url(book_url))\n                star_rating = safe_find(review_elem, \"star-rating\")\n                rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n                comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n                date_str = get_tag_text(safe_find(comment, \"span\"))\n                date = None\n                if date_str:\n                    try:\n                        date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                    except ValueError:\n                        date = None\n                review_text = \"\"\n                if comment:\n                    span = safe_find(comment, \"span\")\n                    if span:\n                        siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                        review_text = \"\\n\".join(siblings).strip()\n                user_reviews.append(\n                    BookReview(\n                        review_id=review_id,\n                        book_id=book_id,\n                        edition_id=edition_id,\n                        user_id=user_id,\n                        rating=rating,\n                        review_text=review_text,\n                        reviewed_at=date,\n                    )\n                )\n            next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n        except (AttributeError, ValueError, IndexError) as e:  # pragma: no cover - defensive\n            logger.error(f\"Failed to parse user reviews: {e}\")\n            raise ParsingError(\"Failed to parse user reviews.\") from e\n\n        logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n        return Pagination(\n            results=user_reviews,\n            limit=50,\n            page=page,\n            total=len(user_reviews),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page_link),\n        )\n\n    def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n        \"\"\"\n        Retrieves reading statistics for a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        UserReadStats\n            The user's reading statistics.\n        \"\"\"\n        self._validate_login()\n        logger.info(f\"Getting read stats for user_id: {user_id}\")\n        url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json().get(\"response\", {})\n\n        stats = UserReadStats(\n            user_id=user_id,\n            year=json_data.get(\"ano\"),\n            books_read=json_data.get(\"lido\"),\n            pages_read=json_data.get(\"paginas_lidas\"),\n            total_pages=json_data.get(\"paginas_total\"),\n            percent_complete=json_data.get(\"percentual_lido\"),\n            books_total=json_data.get(\"total\"),\n            reading_speed=json_data.get(\"velocidade_dia\"),\n            ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n        )\n        logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n        return stats\n\n    def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n        \"\"\"\n        Retrieves a user's bookcase.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        bookcase_option : BookcaseOption\n            The type of bookcase to retrieve.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[UserBook]\n            A paginated list of books in the user's bookcase.\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n        logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n        results = []\n        for r in json_data.get(\"response\", []):\n            edicao = r.get(\"edicao\", {})\n            results.append(\n                UserBook(\n                    user_id=user_id,\n                    book_id=edicao.get(\"livro_id\"),\n                    edition_id=edicao.get(\"id\"),\n                    rating=r.get(\"ranking\"),\n                    is_favorite=r.get(\"favorito\"),\n                    is_wishlist=r.get(\"desejado\"),\n                    is_tradable=r.get(\"troco\"),\n                    is_owned=r.get(\"tenho\"),\n                    is_loaned=r.get(\"emprestei\"),\n                    reading_goal_year=r.get(\"meta\"),\n                    pages_read=r.get(\"paginas_lidas\"),\n                )\n            )\n\n        logger.info(f\"Found {len(results)} books on page {page}.\")\n        return Pagination(\n            limit=100,\n            results=results,\n            total=len(results),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page),\n            page=page,\n        )\n\n    def search(\n        self,\n        query: str,\n        gender: UserGender | None = None,\n        state: BrazilianState | None = None,\n        page: int = 1,\n        limit: int = 100,\n    ) -&gt; Pagination[UserSearch]:\n        \"\"\"Search for users on Skoob.\n\n        Parameters\n        ----------\n        query : str\n            The search query for usernames or names.\n        gender : UserGender, optional\n            Optional gender filter (M/F), by default ``None``.\n        state : BrazilianState, optional\n            Optional state filter (e.g., ``SP``), by default ``None``.\n        page : int, optional\n            Page number to fetch, by default ``1``.\n        limit : int, optional\n            Number of users per page, by default ``100``.\n\n        Returns\n        -------\n        Pagination[UserSearch]\n            A paginated list of users matching the criteria.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure is invalid or parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"example\").page\n        1\n        \"\"\"\n        self._validate_login()\n\n        url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n        if gender:\n            url += f\"/sexo:{gender.value}\"\n        if state:\n            url += f\"/uf:{state.value}\"\n\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        try:\n            user_divs = safe_find_all(\n                soup,\n                \"div\",\n                attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n            )\n            results: list[UserSearch] = []\n\n            for div in user_divs:\n                anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n                if not anchor:\n                    continue  # pragma: no cover - defensive\n\n                href = get_tag_attr(anchor, \"href\")\n                full_url = f\"{self.base_url}{href}\"\n                match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n                if not match:\n                    continue  # pragma: no cover - defensive\n\n                user_id = int(match.group(1))\n                username = match.group(2)\n                name = get_tag_text(anchor)\n\n                logger.debug(\n                    \"User ID: %s / Username: %s / Name: %s / URL: %s\",\n                    user_id,\n                    username,\n                    name,\n                    full_url,\n                )\n\n                results.append(\n                    UserSearch(\n                        id=user_id,\n                        username=username,\n                        name=name,\n                        url=full_url,\n                    )\n                )\n\n            total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n            total_text = get_tag_text(total_tag)\n            total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n\n            next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n            has_next = next_page is not None\n\n            return Pagination[UserSearch](\n                results=results,\n                page=page,\n                total=total,\n                limit=limit,\n                has_next_page=has_next,\n            )\n\n        except Exception as e:  # pragma: no cover - defensive\n            raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.__init__","title":"<code>__init__(client, auth_service)</code>","text":"<p>Initialize the service with dependencies.</p> <p>The service depends on :class:<code>AuthService</code> to validate the current session before performing operations that require authentication such as retrieving your own profile or editing bookshelf information.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <code>auth_service</code> <code>AuthService</code> <p>The authentication service.</p> required Source code in <code>pyskoob/users.py</code> <pre><code>def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n    \"\"\"Initialize the service with dependencies.\n\n    The service depends on :class:`AuthService` to validate the current\n    session before performing operations that require authentication such\n    as retrieving your own profile or editing bookshelf information.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n    auth_service : AuthService\n        The authentication service.\n    \"\"\"\n    super().__init__(client, auth_service)\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_bookcase","title":"<code>get_bookcase(user_id, bookcase_option, page=1)</code>","text":"<p>Retrieves a user's bookcase.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>bookcase_option</code> <code>BookcaseOption</code> <p>The type of bookcase to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[UserBook]</code> <p>A paginated list of books in the user's bookcase.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n    \"\"\"\n    Retrieves a user's bookcase.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    bookcase_option : BookcaseOption\n        The type of bookcase to retrieve.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[UserBook]\n        A paginated list of books in the user's bookcase.\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n    logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n    results = []\n    for r in json_data.get(\"response\", []):\n        edicao = r.get(\"edicao\", {})\n        results.append(\n            UserBook(\n                user_id=user_id,\n                book_id=edicao.get(\"livro_id\"),\n                edition_id=edicao.get(\"id\"),\n                rating=r.get(\"ranking\"),\n                is_favorite=r.get(\"favorito\"),\n                is_wishlist=r.get(\"desejado\"),\n                is_tradable=r.get(\"troco\"),\n                is_owned=r.get(\"tenho\"),\n                is_loaned=r.get(\"emprestei\"),\n                reading_goal_year=r.get(\"meta\"),\n                pages_read=r.get(\"paginas_lidas\"),\n            )\n        )\n\n    logger.info(f\"Found {len(results)} books on page {page}.\")\n    return Pagination(\n        limit=100,\n        results=results,\n        total=len(results),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page),\n        page=page,\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_by_id","title":"<code>get_by_id(user_id)</code>","text":"<p>Retrieves a user by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The user's information.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the user with the given ID is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).name\n'Example'\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def get_by_id(self, user_id: int) -&gt; User:\n    \"\"\"\n    Retrieves a user by their ID.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    User\n        The user's information.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the user with the given ID is not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).name\n    'Example'\n    \"\"\"\n    self._validate_login()\n    logger.info(f\"Getting user by id: {user_id}\")\n    url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.warning(f\"User with ID {user_id} not found.\")\n        raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n    user = User.model_validate(user_data)\n    logger.info(f\"Successfully retrieved user: '{user.name}'\")\n    return user\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_read_stats","title":"<code>get_read_stats(user_id)</code>","text":"<p>Retrieves reading statistics for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>UserReadStats</code> <p>The user's reading statistics.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n    \"\"\"\n    Retrieves reading statistics for a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    UserReadStats\n        The user's reading statistics.\n    \"\"\"\n    self._validate_login()\n    logger.info(f\"Getting read stats for user_id: {user_id}\")\n    url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json().get(\"response\", {})\n\n    stats = UserReadStats(\n        user_id=user_id,\n        year=json_data.get(\"ano\"),\n        books_read=json_data.get(\"lido\"),\n        pages_read=json_data.get(\"paginas_lidas\"),\n        total_pages=json_data.get(\"paginas_total\"),\n        percent_complete=json_data.get(\"percentual_lido\"),\n        books_total=json_data.get(\"total\"),\n        reading_speed=json_data.get(\"velocidade_dia\"),\n        ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n    )\n    logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n    return stats\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_relations","title":"<code>get_relations(user_id, relation, page=1)</code>","text":"<p>Retrieves a user's relations (friends, followers, following).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>relation</code> <code>UsersRelation</code> <p>The type of relation to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[int]</code> <p>A paginated list of user IDs.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n[2, 3]\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n    \"\"\"\n    Retrieves a user's relations (friends, followers, following).\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    relation : UsersRelation\n        The type of relation to retrieve.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[int]\n        A paginated list of user IDs.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n    [2, 3]\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n    logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    soup = self.parse_html(response.text)\n    try:\n        users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n        users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n        next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError) as e:  # pragma: no cover - defensive\n        logger.error(f\"Failed to parse user relations: {e}\")\n        raise ParsingError(\"Failed to parse user relations.\") from e\n\n    logger.info(f\"Found {len(users_id)} users on page {page}.\")\n    return Pagination(\n        results=users_id,\n        limit=100,\n        page=page,\n        total=len(users_id),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_reviews","title":"<code>get_reviews(user_id, page=1)</code>","text":"<p>Retrieves reviews made by a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookReview]</code> <p>A paginated list of book reviews.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n    \"\"\"\n    Retrieves reviews made by a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookReview]\n        A paginated list of book reviews.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n    logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    user_reviews: list[BookReview] = []\n    soup = self.parse_html(response.text)\n    try:\n        reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n        for review_elem in reviews_html:\n            review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n            book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n            book_url = get_tag_attr(book_anchor, \"href\")\n            book_id = int(get_book_id_from_url(book_url))\n            edition_id = int(get_book_edition_id_from_url(book_url))\n            star_rating = safe_find(review_elem, \"star-rating\")\n            rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n            comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n            date_str = get_tag_text(safe_find(comment, \"span\"))\n            date = None\n            if date_str:\n                try:\n                    date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                except ValueError:\n                    date = None\n            review_text = \"\"\n            if comment:\n                span = safe_find(comment, \"span\")\n                if span:\n                    siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                    review_text = \"\\n\".join(siblings).strip()\n            user_reviews.append(\n                BookReview(\n                    review_id=review_id,\n                    book_id=book_id,\n                    edition_id=edition_id,\n                    user_id=user_id,\n                    rating=rating,\n                    review_text=review_text,\n                    reviewed_at=date,\n                )\n            )\n        next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n    except (AttributeError, ValueError, IndexError) as e:  # pragma: no cover - defensive\n        logger.error(f\"Failed to parse user reviews: {e}\")\n        raise ParsingError(\"Failed to parse user reviews.\") from e\n\n    logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n    return Pagination(\n        results=user_reviews,\n        limit=50,\n        page=page,\n        total=len(user_reviews),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.search","title":"<code>search(query, gender=None, state=None, page=1, limit=100)</code>","text":"<p>Search for users on Skoob.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query for usernames or names.</p> required <code>gender</code> <code>UserGender</code> <p>Optional gender filter (M/F), by default <code>None</code>.</p> <code>None</code> <code>state</code> <code>BrazilianState</code> <p>Optional state filter (e.g., <code>SP</code>), by default <code>None</code>.</p> <code>None</code> <code>page</code> <code>int</code> <p>Page number to fetch, by default <code>1</code>.</p> <code>1</code> <code>limit</code> <code>int</code> <p>Number of users per page, by default <code>100</code>.</p> <code>100</code> <p>Returns:</p> Type Description <code>Pagination[UserSearch]</code> <p>A paginated list of users matching the criteria.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure is invalid or parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"example\").page\n1\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def search(\n    self,\n    query: str,\n    gender: UserGender | None = None,\n    state: BrazilianState | None = None,\n    page: int = 1,\n    limit: int = 100,\n) -&gt; Pagination[UserSearch]:\n    \"\"\"Search for users on Skoob.\n\n    Parameters\n    ----------\n    query : str\n        The search query for usernames or names.\n    gender : UserGender, optional\n        Optional gender filter (M/F), by default ``None``.\n    state : BrazilianState, optional\n        Optional state filter (e.g., ``SP``), by default ``None``.\n    page : int, optional\n        Page number to fetch, by default ``1``.\n    limit : int, optional\n        Number of users per page, by default ``100``.\n\n    Returns\n    -------\n    Pagination[UserSearch]\n        A paginated list of users matching the criteria.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure is invalid or parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"example\").page\n    1\n    \"\"\"\n    self._validate_login()\n\n    url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n    if gender:\n        url += f\"/sexo:{gender.value}\"\n    if state:\n        url += f\"/uf:{state.value}\"\n\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    try:\n        user_divs = safe_find_all(\n            soup,\n            \"div\",\n            attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n        )\n        results: list[UserSearch] = []\n\n        for div in user_divs:\n            anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n            if not anchor:\n                continue  # pragma: no cover - defensive\n\n            href = get_tag_attr(anchor, \"href\")\n            full_url = f\"{self.base_url}{href}\"\n            match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n            if not match:\n                continue  # pragma: no cover - defensive\n\n            user_id = int(match.group(1))\n            username = match.group(2)\n            name = get_tag_text(anchor)\n\n            logger.debug(\n                \"User ID: %s / Username: %s / Name: %s / URL: %s\",\n                user_id,\n                username,\n                name,\n                full_url,\n            )\n\n            results.append(\n                UserSearch(\n                    id=user_id,\n                    username=username,\n                    name=name,\n                    url=full_url,\n                )\n            )\n\n        total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n        total_text = get_tag_text(total_tag)\n        total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n\n        next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        has_next = next_page is not None\n\n        return Pagination[UserSearch](\n            results=results,\n            page=page,\n            total=total,\n            limit=limit,\n            has_next_page=has_next,\n        )\n\n    except Exception as e:  # pragma: no cover - defensive\n        raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"}]}