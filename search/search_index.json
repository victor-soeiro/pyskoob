{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PySkoob Documentation","text":"<p>Welcome to the PySkoob documentation. This site provides usage examples and a reference of the available services.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyskoob\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    books = client.books.search(\"python\").results\n</code></pre>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#pyskoob.client.SkoobClient","title":"<code>SkoobClient</code>","text":"<p>Facade for interacting with Skoob services.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with SkoobClient() as client:\n...     client.auth.login_with_cookies(\"token\")\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>class SkoobClient:\n    \"\"\"Facade for interacting with Skoob services.\n\n    Examples\n    --------\n    &gt;&gt;&gt; with SkoobClient() as client:\n    ...     client.auth.login_with_cookies(\"token\")\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the SkoobClient.\n        \"\"\"\n        self._client = HttpxSyncClient()\n        self.auth = AuthService(self._client)\n        self.books = BookService(self._client)\n        self.authors = AuthorService(self._client)\n        self.users = UserService(self._client, self.auth)\n        self.me = SkoobProfileService(self._client, self.auth)\n        self.publishers = PublisherService(self._client)\n\n    def __enter__(self) -&gt; SkoobClient:\n        \"\"\"\n        Enter the runtime context for the SkoobClient.\n\n        Returns\n        -------\n        SkoobClient\n            The SkoobClient instance.\n\n        Examples\n        --------\n        &gt;&gt;&gt; with SkoobClient() as client:\n        ...     pass\n        \"\"\"\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb) -&gt; bool | None:\n        \"\"\"\n        Exit the runtime context, closing the HTTPX client.\n\n        Parameters\n        ----------\n        exc_type : type\n            The exception type.\n        exc_val : Exception\n            The exception value.\n        exc_tb : traceback\n            The traceback object.\n\n        Returns\n        -------\n        bool or None\n            ``True`` to suppress the exception; otherwise ``None`` or ``False``\n            to propagate it.\n\n        Examples\n        --------\n        &gt;&gt;&gt; client = SkoobClient()\n        &gt;&gt;&gt; client.__exit__(None, None, None)\n        None\n        \"\"\"\n        self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the runtime context for the SkoobClient.</p> <p>Returns:</p> Type Description <code>SkoobClient</code> <p>The SkoobClient instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with SkoobClient() as client:\n...     pass\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>def __enter__(self) -&gt; SkoobClient:\n    \"\"\"\n    Enter the runtime context for the SkoobClient.\n\n    Returns\n    -------\n    SkoobClient\n        The SkoobClient instance.\n\n    Examples\n    --------\n    &gt;&gt;&gt; with SkoobClient() as client:\n    ...     pass\n    \"\"\"\n    return self\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the runtime context, closing the HTTPX client.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type</code> <p>The exception type.</p> required <code>exc_val</code> <code>Exception</code> <p>The exception value.</p> required <code>exc_tb</code> <code>traceback</code> <p>The traceback object.</p> required <p>Returns:</p> Type Description <code>bool or None</code> <p><code>True</code> to suppress the exception; otherwise <code>None</code> or <code>False</code> to propagate it.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; client = SkoobClient()\n&gt;&gt;&gt; client.__exit__(None, None, None)\nNone\n</code></pre> Source code in <code>pyskoob/client.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb) -&gt; bool | None:\n    \"\"\"\n    Exit the runtime context, closing the HTTPX client.\n\n    Parameters\n    ----------\n    exc_type : type\n        The exception type.\n    exc_val : Exception\n        The exception value.\n    exc_tb : traceback\n        The traceback object.\n\n    Returns\n    -------\n    bool or None\n        ``True`` to suppress the exception; otherwise ``None`` or ``False``\n        to propagate it.\n\n    Examples\n    --------\n    &gt;&gt;&gt; client = SkoobClient()\n    &gt;&gt;&gt; client.__exit__(None, None, None)\n    None\n    \"\"\"\n    self._client.close()\n</code></pre>"},{"location":"#pyskoob.client.SkoobClient.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the SkoobClient.</p> Source code in <code>pyskoob/client.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the SkoobClient.\n    \"\"\"\n    self._client = HttpxSyncClient()\n    self.auth = AuthService(self._client)\n    self.books = BookService(self._client)\n    self.authors = AuthorService(self._client)\n    self.users = UserService(self._client, self.auth)\n    self.me = SkoobProfileService(self._client, self.auth)\n    self.publishers = PublisherService(self._client)\n</code></pre>"},{"location":"#pyskoob.auth.AuthService","title":"<code>AuthService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> Source code in <code>pyskoob/auth.py</code> <pre><code>class AuthService(BaseSkoobService):\n    def __init__(self, client: SyncHTTPClient):\n        \"\"\"Manage Skoob authentication and session validation.\n\n        The service wraps the login workflow and stores the session state so\n        other services (such as :class:`UserService` or\n        :class:`SkoobProfileService`) can verify that requests are\n        authenticated before accessing user data.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import httpx\n        &gt;&gt;&gt; service = AuthService(httpx.Client())\n        \"\"\"\n        super().__init__(client)\n        self._is_logged_in = False\n\n    def login_with_cookies(self, session_token: str) -&gt; User:\n        \"\"\"\n        Logs in the user using a session token.\n\n        Parameters\n        ----------\n        session_token : str\n            The PHPSESSID token from Skoob.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\n        User(name='example')\n        \"\"\"\n        logger.info(\"Attempting to log in with session token.\")\n        self.client.cookies.update({\"PHPSESSID\": session_token})\n        user = self.get_my_info()\n        self._is_logged_in = True\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    def login(self, email: str, password: str) -&gt; User:\n        \"\"\"\n        Logs in the user using email and password.\n\n        Parameters\n        ----------\n        email : str\n            The user's email address.\n        password : str\n            The user's password.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Raises\n        ------\n        ConnectionError\n            If authentication fails or the session cannot be established.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\n        User(name='example')\n        \"\"\"\n        logger.info(\"Attempting to log in with email and password.\")\n        url = f\"{self.base_url}/v1/login\"\n        data = {\n            \"data[Usuario][email]\": email,\n            \"data[Usuario][senha]\": password,\n            \"data[Login][automatico]\": True,\n        }\n\n        response = self.client.post(url, data=data)\n        response.raise_for_status()\n\n        try:\n            json_data = response.json()\n        except ValueError as exc:\n            logger.error(\"Login response was not valid JSON\")\n            raise ConnectionError(\"Invalid response format\") from exc\n        if not json_data.get(\"success\", False):\n            logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n            raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n\n        self._is_logged_in = True\n        user = self.get_my_info()\n        logger.info(\"Successfully logged in as user: '%s'\", user.name)\n        return user\n\n    def get_my_info(self) -&gt; User:\n        \"\"\"\n        Retrieves the authenticated user's information.\n\n        Returns\n        -------\n        User\n            The authenticated user's information.\n\n        Raises\n        ------\n        ConnectionError\n            If it fails to retrieve user information.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_my_info().name\n        'Example User'\n        \"\"\"\n        logger.info(\"Getting authenticated user's information.\")\n        url = f\"{self.base_url}/v1/user/stats:true\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n            raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n        user = User.model_validate(user_data)\n        logger.info(\"Successfully retrieved user: '%s'\", user.name)\n        return user\n\n    def validate_login(self) -&gt; None:\n        \"\"\"\n        Validates if the user is logged in.\n\n        Raises\n        ------\n        PermissionError\n            If the user is not logged in.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.validate_login()\n        None\n        \"\"\"\n        logger.debug(\"Validating login status.\")\n        if not self._is_logged_in:\n            logger.warning(\"Validation failed: User is not logged in.\")\n            raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n        logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.__init__","title":"<code>__init__(client)</code>","text":"<p>Manage Skoob authentication and session validation.</p> <p>The service wraps the login workflow and stores the session state so other services (such as :class:<code>UserService</code> or :class:<code>SkoobProfileService</code>) can verify that requests are authenticated before accessing user data.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import httpx\n&gt;&gt;&gt; service = AuthService(httpx.Client())\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def __init__(self, client: SyncHTTPClient):\n    \"\"\"Manage Skoob authentication and session validation.\n\n    The service wraps the login workflow and stores the session state so\n    other services (such as :class:`UserService` or\n    :class:`SkoobProfileService`) can verify that requests are\n    authenticated before accessing user data.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import httpx\n    &gt;&gt;&gt; service = AuthService(httpx.Client())\n    \"\"\"\n    super().__init__(client)\n    self._is_logged_in = False\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.get_my_info","title":"<code>get_my_info()</code>","text":"<p>Retrieves the authenticated user's information.</p> <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If it fails to retrieve user information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_my_info().name\n'Example User'\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def get_my_info(self) -&gt; User:\n    \"\"\"\n    Retrieves the authenticated user's information.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Raises\n    ------\n    ConnectionError\n        If it fails to retrieve user information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_my_info().name\n    'Example User'\n    \"\"\"\n    logger.info(\"Getting authenticated user's information.\")\n    url = f\"{self.base_url}/v1/user/stats:true\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.error(\"Failed to retrieve user information. The session token might be invalid.\")\n        raise ConnectionError(\"Failed to retrieve user information. The session token might be invalid.\")\n\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n    user = User.model_validate(user_data)\n    logger.info(\"Successfully retrieved user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.login","title":"<code>login(email, password)</code>","text":"<p>Logs in the user using email and password.</p> <p>Parameters:</p> Name Type Description Default <code>email</code> <code>str</code> <p>The user's email address.</p> required <code>password</code> <code>str</code> <p>The user's password.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If authentication fails or the session cannot be established.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\nUser(name='example')\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def login(self, email: str, password: str) -&gt; User:\n    \"\"\"\n    Logs in the user using email and password.\n\n    Parameters\n    ----------\n    email : str\n        The user's email address.\n    password : str\n        The user's password.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Raises\n    ------\n    ConnectionError\n        If authentication fails or the session cannot be established.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.login(\"user@example.com\", \"password\")\n    User(name='example')\n    \"\"\"\n    logger.info(\"Attempting to log in with email and password.\")\n    url = f\"{self.base_url}/v1/login\"\n    data = {\n        \"data[Usuario][email]\": email,\n        \"data[Usuario][senha]\": password,\n        \"data[Login][automatico]\": True,\n    }\n\n    response = self.client.post(url, data=data)\n    response.raise_for_status()\n\n    try:\n        json_data = response.json()\n    except ValueError as exc:\n        logger.error(\"Login response was not valid JSON\")\n        raise ConnectionError(\"Invalid response format\") from exc\n    if not json_data.get(\"success\", False):\n        logger.error(\"Login failed: %s\", json_data.get(\"message\", \"Unknown error\"))\n        raise ConnectionError(\"Failed to login: {}\".format(json_data.get(\"message\", \"Unknown error\")))\n\n    self._is_logged_in = True\n    user = self.get_my_info()\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.login_with_cookies","title":"<code>login_with_cookies(session_token)</code>","text":"<p>Logs in the user using a session token.</p> <p>Parameters:</p> Name Type Description Default <code>session_token</code> <code>str</code> <p>The PHPSESSID token from Skoob.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The authenticated user's information.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\nUser(name='example')\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def login_with_cookies(self, session_token: str) -&gt; User:\n    \"\"\"\n    Logs in the user using a session token.\n\n    Parameters\n    ----------\n    session_token : str\n        The PHPSESSID token from Skoob.\n\n    Returns\n    -------\n    User\n        The authenticated user's information.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.login_with_cookies(\"PHPSESSID=abc123\")\n    User(name='example')\n    \"\"\"\n    logger.info(\"Attempting to log in with session token.\")\n    self.client.cookies.update({\"PHPSESSID\": session_token})\n    user = self.get_my_info()\n    self._is_logged_in = True\n    logger.info(\"Successfully logged in as user: '%s'\", user.name)\n    return user\n</code></pre>"},{"location":"#pyskoob.auth.AuthService.validate_login","title":"<code>validate_login()</code>","text":"<p>Validates if the user is logged in.</p> <p>Raises:</p> Type Description <code>PermissionError</code> <p>If the user is not logged in.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.validate_login()\nNone\n</code></pre> Source code in <code>pyskoob/auth.py</code> <pre><code>def validate_login(self) -&gt; None:\n    \"\"\"\n    Validates if the user is logged in.\n\n    Raises\n    ------\n    PermissionError\n        If the user is not logged in.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.validate_login()\n    None\n    \"\"\"\n    logger.debug(\"Validating login status.\")\n    if not self._is_logged_in:\n        logger.warning(\"Validation failed: User is not logged in.\")\n        raise PermissionError(\"User is not logged in. Please call 'login_with_cookies' first.\")\n    logger.debug(\"Validation successful: User is logged in.\")\n</code></pre>"},{"location":"#further-reading","title":"Further Reading","text":"<ul> <li>Advanced Usage</li> <li>Stable Public API</li> </ul>"},{"location":"advanced_usage/","title":"Advanced Usage","text":"<p>This section shows more involved examples of working with PySkoob.</p>"},{"location":"advanced_usage/#handling-pagination","title":"Handling Pagination","text":"<p>Several services return a <code>Pagination</code> object that exposes the <code>has_next_page</code> flag. You can use this flag to iterate over all pages:</p> <pre><code>from pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookSearch\n\nwith SkoobClient() as client:\n    page = 1\n    while True:\n        results = client.books.search(\"Python\", BookSearch.TITLE, page=page)\n        for book in results.results:\n            print(f\"[{page}] {book.title}\")\n        if not results.has_next_page:\n            break\n        page += 1\n</code></pre>"},{"location":"advanced_usage/#asynchronous-http-client","title":"Asynchronous HTTP Client","text":"<p>PySkoob ships with <code>HttpxAsyncClient</code> for making asynchronous HTTP requests. While the high level services are synchronous, you can use the async client when integrating with an async application:</p> <pre><code>import asyncio\nfrom pyskoob import HttpxAsyncClient\n\nasync def main() -&gt; None:\n    client = HttpxAsyncClient()\n    resp = await client.get(\"https://www.skoob.com.br\")\n    print(resp.text[:100])\n    await client.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"author_service/","title":"Author Service","text":"<p>The <code>AuthorService</code> provides search capabilities for authors on Skoob. It scrapes Skoob's HTML pages and returns lightweight results with the following fields:</p> <ul> <li><code>id</code>: numeric identifier extracted from the author URL</li> <li><code>name</code>: the author's display name</li> <li><code>nickname</code>: nickname shown below the name</li> <li><code>url</code>: absolute URL to the author's page on Skoob</li> <li><code>img_url</code>: avatar image URL</li> </ul> <p>Skoob displays publication, reader and follower counts on the search results page, but these values are often outdated when compared with the author's profile page. To avoid exposing misleading data, <code>AuthorService</code> intentionally omits these numbers.</p>"},{"location":"author_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    results = client.authors.search(\"Asimov\")\n    for author in results.results:\n        print(author.name, author.id)\n    if results.has_next_page:\n        # fetch the next page of results\n        more_results = client.authors.search(\"Asimov\", page=results.next_page)\n</code></pre> <p><code>search()</code> returns only the first page of results. Use <code>results.has_next_page</code> to fetch additional pages.</p>"},{"location":"author_service/#pyskoob.authors.AuthorService","title":"<code>AuthorService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving authors.</p> <p>The service scrapes HTML pages from Skoob to return author search results.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service = AuthorService(None)\n&gt;&gt;&gt; service.search(\"john\").results\n[]\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>class AuthorService(BaseSkoobService):\n    \"\"\"High level operations for retrieving authors.\n\n    The service scrapes HTML pages from Skoob to return author search results.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service = AuthorService(None)\n    &gt;&gt;&gt; service.search(\"john\").results\n    []\n    \"\"\"\n\n    def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n        \"\"\"Search for authors by name.\n\n        Parameters\n        ----------\n        query : str\n            Term to look for.\n        page : int, optional\n            Page number for pagination, by default ``1``.\n\n        Returns\n        -------\n        Pagination[AuthorSearchResult]\n            Paginated list of authors matching the query.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"john\").total\n        0\n        \"\"\"\n        url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n        logger.info(\"Searching authors with query '%s' page %s\", query, page)\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n\n        author_blocks = []\n        for div in safe_find_all(soup, \"div\"):\n            style = str(div.get(\"style\") or \"\")\n            if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n                author_blocks.append(div)\n\n        results = [r for div in author_blocks if (r := self._parse_author_block(div))]\n        total = self._extract_total_results(soup)\n        has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=results,\n            limit=len(results),\n            page=page,\n            total=total,\n            has_next_page=has_next,\n        )\n\n    def _parse_author_block(self, div: Tag) -&gt; AuthorSearchResult | None:\n        \"\"\"Parse a single author listing block.\n\n        Parameters\n        ----------\n        div : Tag\n            The HTML ``div`` containing the author information.\n\n        Returns\n        -------\n        AuthorSearchResult or None\n            Parsed author data or ``None`` if required fields are missing.\n        \"\"\"\n        img_tag = safe_find(div, \"img\", {\"class\": \"img-rounded\"})\n        links = [a for a in safe_find_all(div, \"a\", {\"href\": re.compile(r\"/autor/\\d+-\")}) if get_tag_attr(a, \"href\")]\n        link_tag = next((a for a in links if get_tag_text(a)), None)\n        if not (img_tag and link_tag):\n            return None\n        href = get_tag_attr(link_tag, \"href\")\n        return AuthorSearchResult(\n            id=int(get_author_id_from_url(href)),\n            name=get_tag_text(link_tag),\n            url=f\"{self.base_url}{href}\",\n            nickname=get_tag_text(safe_find(div, \"i\")),\n            img_url=get_tag_attr(img_tag, \"src\"),\n        )\n\n    @staticmethod\n    def _extract_total_results(soup: Tag) -&gt; int:\n        \"\"\"Extract the total number of results from the page.\n\n        Parameters\n        ----------\n        soup : Tag\n            Parsed search results page.\n\n        Returns\n        -------\n        int\n            Total number of authors found or ``0`` if unavailable.\n\n        Examples\n        --------\n        &gt;&gt;&gt; AuthorService._extract_total_results(\n        ...     BeautifulSoup(\"&lt;div class='contador'&gt;1 encontrados&lt;/div&gt;\", 'html.parser')\n        ... )\n        1\n        \"\"\"\n        contador = safe_find(soup, \"div\", {\"class\": \"contador\"})\n        match = re.search(r\"(\\d+)\", get_tag_text(contador))\n        return int(match.group(1)) if match else 0\n</code></pre>"},{"location":"author_service/#pyskoob.authors.AuthorService.search","title":"<code>search(query, page=1)</code>","text":"<p>Search for authors by name.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Term to look for.</p> required <code>page</code> <code>int</code> <p>Page number for pagination, by default <code>1</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[AuthorSearchResult]</code> <p>Paginated list of authors matching the query.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"john\").total\n0\n</code></pre> Source code in <code>pyskoob/authors.py</code> <pre><code>def search(self, query: str, page: int = 1) -&gt; Pagination[AuthorSearchResult]:\n    \"\"\"Search for authors by name.\n\n    Parameters\n    ----------\n    query : str\n        Term to look for.\n    page : int, optional\n        Page number for pagination, by default ``1``.\n\n    Returns\n    -------\n    Pagination[AuthorSearchResult]\n        Paginated list of authors matching the query.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"john\").total\n    0\n    \"\"\"\n    url = f\"{self.base_url}/autor/lista/busca:{query}/mpage:{page}\"\n    logger.info(\"Searching authors with query '%s' page %s\", query, page)\n    response = self.client.get(url)\n    response.raise_for_status()\n    soup = self.parse_html(response.text)\n\n    author_blocks = []\n    for div in safe_find_all(soup, \"div\"):\n        style = str(div.get(\"style\") or \"\")\n        if \"border-bottom:#ccc\" in style and \"margin-bottom:10px\" in style:\n            author_blocks.append(div)\n\n    results = [r for div in author_blocks if (r := self._parse_author_block(div))]\n    total = self._extract_total_results(soup)\n    has_next = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n    return Pagination(\n        results=results,\n        limit=len(results),\n        page=page,\n        total=total,\n        has_next_page=has_next,\n    )\n</code></pre>"},{"location":"books_service/","title":"Books Service","text":"<p>The <code>BookService</code> allows searching for books and retrieving detailed information.</p>"},{"location":"books_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookSearch\n\nwith SkoobClient() as client:\n    results = client.books.search(\"Duna\", BookSearch.TITLE)\n    for book in results.results:\n        print(book.title, book.book_id)\n</code></pre> <p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving and searching books.</p> <p>The service parses HTML and JSON responses from Skoob and exposes helpers to fetch book details, reviews and user lists. It can be used independently from authentication, but other services may combine it with :class:<code>AuthService</code> to operate on the authenticated user's data.</p> Source code in <code>pyskoob/books.py</code> <pre><code>class BookService(BaseSkoobService):\n    \"\"\"High level operations for retrieving and searching books.\n\n    The service parses HTML and JSON responses from Skoob and exposes\n    helpers to fetch book details, reviews and user lists. It can be used\n    independently from authentication, but other services may combine it\n    with :class:`AuthService` to operate on the authenticated user's data.\n    \"\"\"\n\n    def search(\n        self,\n        query: str,\n        search_by: BookSearch = BookSearch.TITLE,\n        page: int = 1,\n    ) -&gt; Pagination[BookSearchResult]:\n        \"\"\"\n        Searches for books by query and type.\n\n        Parameters\n        ----------\n        query : str\n            The search query string.\n        search_by : BookSearch, optional\n            The type of search (title, author, etc.), by default\n            ``BookSearch.TITLE``.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookSearchResult]\n            A paginated list of search results.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"Duna\").results[0].title\n        'Duna'\n        \"\"\"\n        url = f\"{self.base_url}/livro/lista/busca:{query}/tipo:{search_by.value}/mpage:{page}\"\n        logger.info(f\"Searching for books with query: '{query}' on page {page}\")\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n\n            limit = 30\n            results: list[BookSearchResult | None] = [\n                self._parse_search_result(book_div) for book_div in safe_find_all(soup, \"div\", {\"class\": \"box_lista_busca_vertical\"})\n            ]\n            cleaned_results: list[BookSearchResult] = [i for i in results if i]\n\n            total_results = self._extract_total_results(soup)\n            next_page_link = True if page * limit &lt; total_results else False\n        except (AttributeError, ValueError, IndexError, TypeError) as e:\n            logger.error(f\"Failed to parse book search results: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse book search results.\") from e\n        except Exception as e:\n            logger.error(\n                f\"An unexpected error occurred during book search: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during book search.\") from e\n\n        logger.info(\n            \"Found %s books on page %s, total %s results.\",\n            len(results),\n            page,\n            total_results,\n        )\n        return Pagination[BookSearchResult](\n            results=cleaned_results,\n            limit=30,\n            page=page,\n            total=total_results,\n            has_next_page=next_page_link,\n        )\n\n    def get_by_id(self, edition_id: int) -&gt; Book:\n        \"\"\"\n        Retrieves a book by its edition ID.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        Book\n            Book object populated with detailed information.\n\n        Raises\n        ------\n        FileNotFoundError\n            If no book is found with the given edition_id.\n        ParsingError\n            If parsing or HTTP errors occur.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).title\n        'Some Book'\n        \"\"\"\n        logger.info(f\"Getting book by edition_id: {edition_id}\")\n        url = f\"{self.base_url}/v1/book/{edition_id}/stats:true\"\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            json_data = response.json().get(\"response\")\n            if not json_data:\n                cod_description = response.json().get(\"cod_description\", \"No description provided.\")\n                error_msg = f\"No data found for edition_id {edition_id}. Description: {cod_description}\"\n                logger.warning(error_msg)\n                raise FileNotFoundError(error_msg)\n            self._clean_book_json_data(json_data)\n            book = Book.model_validate(json_data)\n            logger.info(\n                \"Successfully retrieved book: '%s' (Edition ID: %s)\",\n                book.title,\n                edition_id,\n            )\n            return book\n        except FileNotFoundError:\n            raise\n        except Exception as e:\n            logger.error(\n                f\"Error retrieving book for edition_id {edition_id}: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(f\"Failed to retrieve book for edition_id {edition_id}.\") from e\n\n    def get_reviews(self, book_id: int, edition_id: int | None = None, page: int = 1) -&gt; Pagination[BookReview]:\n        \"\"\"\n        Retrieves reviews for a book.\n\n        Parameters\n        ----------\n        book_id : int\n            Book ID for which to retrieve reviews.\n        edition_id : int or None, optional\n            Specific edition ID, or auto-detected if None.\n        page : int, optional\n            Page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookReview]\n            A paginated list of reviews for the book.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes or parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_reviews(123).results\n        [...]\n        \"\"\"\n        url = f\"{self.base_url}/livro/resenhas/{book_id}/mpage:{page}/limit:50\"\n        if edition_id:\n            url += f\"/edition:{edition_id}\"\n        logger.info(f\"Getting reviews for book_id: {book_id}, page: {page}\")\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            if edition_id is None:\n                edition_id = self._extract_edition_id_from_reviews_page(soup)\n            book_reviews = [\n                review\n                for review in (\n                    self._parse_review(r, book_id, edition_id) for r in safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n                )\n                if review is not None\n            ]\n            next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError, TypeError) as e:\n            logger.error(f\"Failed to parse book reviews: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse book reviews.\") from e\n        except Exception as e:\n            logger.error(\n                f\"An unexpected error occurred during review fetching: {e}\",\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during review fetching.\") from e\n        logger.info(f\"Found {len(book_reviews)} reviews on page {page}.\")\n        return Pagination[BookReview](\n            results=book_reviews,\n            limit=50,\n            page=page,\n            total=len(book_reviews),\n            has_next_page=next_page_link is not None,\n        )\n\n    def get_users_by_status(\n        self,\n        book_id: int,\n        status: BookUserStatus,\n        edition_id: int | None = None,\n        limit: int = 500,\n        page: int = 1,\n    ) -&gt; Pagination[int]:\n        \"\"\"\n        Retrieves users who have a book with a specific status.\n\n        Parameters\n        ----------\n        book_id : int\n            The ID of the book.\n        status : BookUserStatus\n            The status of the book in the user's shelf.\n        edition_id : int or None, optional\n            The edition ID of the book, by default None.\n        limit : int, optional\n            The number of users to retrieve per page, by default 500.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[int]\n            A paginated list of user IDs.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n        [1, 2, 3]\n        \"\"\"\n        url = f\"{self.base_url}/livro/leitores/{status.value}/{book_id}/limit:{limit}/page:{page}\"\n        if edition_id:\n            url += f\"/edition:{edition_id}\"\n        logger.info(\n            \"Getting users for book_id: %s with status '%s' on page %s\",\n            book_id,\n            status.value,\n            page,\n        )\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            users_id = self._extract_user_ids_from_html(soup)\n            next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError, TypeError) as e:\n            logger.error(f\"Failed to parse users by status: {e}\", exc_info=True)\n            raise ParsingError(\"Failed to parse users by status.\") from e\n        except Exception as e:\n            logger.error(\n                \"An unexpected error occurred during user status fetching: %s\",\n                e,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred during user status fetching.\") from e\n        logger.info(\n            \"Found %s users on page %s.\",\n            len(users_id),\n            page,\n        )\n        return Pagination[int](\n            results=users_id,\n            limit=limit,\n            page=page,\n            total=len(users_id),\n            has_next_page=next_page_link is not None,\n        )\n\n    def _extract_user_ids_from_html(self, soup) -&gt; list[int]:\n        \"\"\"\n        Extracts user IDs from the user list HTML soup.\n\n        Parameters\n        ----------\n        soup : Tag\n            BeautifulSoup Tag containing the user list.\n\n        Returns\n        -------\n        list of int\n            List of user IDs found on the page.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = (\n        ...     \"&lt;div class='livro-leitor-container'&gt;\"\n        ...     \"&lt;a href='/usuario/1-name'&gt;&lt;/a&gt;&lt;/div&gt;\"\n        ... )\n        &gt;&gt;&gt; service._extract_user_ids_from_html(\n        ...     BeautifulSoup(html, 'html.parser')\n        ... )\n        [1]\n        \"\"\"\n        users_html = safe_find_all(soup, \"div\", {\"class\": \"livro-leitor-container\"})\n        users_id = []\n        for user_div in users_html:\n            user_link = safe_find(user_div, \"a\")\n            href = get_tag_attr(user_link, \"href\")\n            if href:\n                user_id = get_user_id_from_url(href)\n                if user_id:\n                    users_id.append(int(user_id))\n                else:\n                    logger.warning(f\"Could not extract user ID from URL: {href}\")\n            else:\n                logger.warning(\"Skipping user_div due to missing 'a' tag or href attribute.\")\n        return users_id\n\n    def _extract_edition_id_from_reviews_page(self, soup) -&gt; int | None:\n        \"\"\"\n        Extracts the edition ID from the reviews page if not provided.\n\n        Parameters\n        ----------\n        soup : Tag\n            BeautifulSoup object of the reviews page.\n\n        Returns\n        -------\n        int or None\n            Edition ID or None if not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = (\n        ...     \"&lt;div id='pg-livro-menu-principal-container'&gt;\"\n        ...     \"&lt;a href='/livro/1-ed3'&gt;&lt;/a&gt;&lt;/div&gt;\"\n        ... )\n        &gt;&gt;&gt; service._extract_edition_id_from_reviews_page(\n        ...     BeautifulSoup(html, 'html.parser')\n        ... )\n        3\n        \"\"\"\n        menu_div = safe_find(soup, \"div\", {\"id\": \"pg-livro-menu-principal-container\"})\n        menu_div_a = safe_find(menu_div, \"a\") if menu_div else None\n        href = get_tag_attr(menu_div_a, \"href\")\n        if href:\n            extracted_edition_id = get_book_edition_id_from_url(href)\n            if extracted_edition_id:\n                return int(extracted_edition_id)\n            else:\n                logger.warning(f\"Could not extract edition_id from URL: {href}\")\n        return None\n\n    def _parse_review(\n        self,\n        r: Tag,\n        book_id: int,\n        edition_id: int | None,\n    ) -&gt; BookReview | None:\n        \"\"\"\n        Parses a single review div into a BookReview object.\n\n        Parameters\n        ----------\n        r : Tag\n            BeautifulSoup Tag for the review.\n        book_id : int\n            The book ID.\n        edition_id : int or None\n            The edition ID.\n\n        Returns\n        -------\n        BookReview or None\n            Parsed review or None if incomplete.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = \"&lt;div id='resenha1'&gt;&lt;/div&gt;\"\n        &gt;&gt;&gt; service._parse_review(\n        ...     BeautifulSoup(html, 'html.parser'),\n        ...     1,\n        ...     None,\n        ... )\n        ... # doctest: +ELLIPSIS\n        \"\"\"\n        review_id_str = get_tag_attr(r, \"id\")\n        review_id = int(review_id_str.replace(\"resenha\", \"\")) if review_id_str else None\n        if review_id is None:\n            logger.warning(f\"Skipping review due to missing or invalid ID: {get_tag_attr(r, 'id')}\")\n            return None\n        user_link = safe_find(r, \"a\", {\"href\": re.compile(r\"/usuario/\")})\n        user_url = get_tag_attr(user_link, \"href\")\n        user_id = int(get_user_id_from_url(user_url)) if user_url else None\n        if user_id is None:\n            logger.warning(f\"Skipping review {review_id} due to missing user ID.\")\n            return None\n        star_tag = safe_find(r, \"star-rating\")\n        rating = float(get_tag_attr(star_tag, \"rate\")) if star_tag and get_tag_attr(star_tag, \"rate\") else 0.0\n        comment_div = safe_find(r, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n        date, review_text = self._extract_review_date_and_text(comment_div, review_id)\n        return BookReview(\n            review_id=review_id,\n            book_id=book_id,\n            edition_id=edition_id,\n            user_id=user_id,\n            rating=rating,\n            review_text=review_text,\n            reviewed_at=date,\n        )\n\n    def _extract_review_date_and_text(self, comment_div: Tag | None, review_id: int) -&gt; tuple[datetime | None, str]:\n        \"\"\"\n        Extracts the review date and text from the comment div.\n\n        Parameters\n        ----------\n        comment_div : Tag\n            BeautifulSoup Tag containing the review comment.\n        review_id : int\n            ID of the review (for logging purposes).\n\n        Returns\n        -------\n        tuple of (datetime or None, str)\n            Parsed review date (if found) and review text.\n\n        Examples\n        --------\n        &gt;&gt;&gt; soup = BeautifulSoup(\n        ...     '&lt;span&gt;01/01/2020&lt;/span&gt; Great',\n        ...     'html.parser',\n        ... )\n        &gt;&gt;&gt; service._extract_review_date_and_text(soup, 1)[1]\n        'Great'\n        \"\"\"\n        date = None\n        review_text = \"\"\n        if comment_div:\n            date_span = safe_find(comment_div, \"span\")\n            date_text = get_tag_text(date_span, strip=True)\n            if date_text:\n                try:\n                    date = datetime.strptime(date_text, \"%d/%m/%Y\")\n                except ValueError:\n                    logger.warning(f\"Could not parse date '{date_text}' for review {review_id}. Setting to None.\")\n            content_parts = []\n            if date_span:\n                for sibling in date_span.next_siblings:\n                    if isinstance(sibling, Tag):\n                        content_parts.append(sibling.get_text(separator=\"\\n\", strip=True))\n                    elif isinstance(sibling, str):\n                        stripped_text = sibling.strip()\n                        if stripped_text:\n                            content_parts.append(stripped_text)\n            else:\n                content_parts.append(comment_div.get_text(separator=\"\\n\", strip=True))\n            review_text = \"\\n\".join(filter(None, content_parts)).strip()\n        return date, review_text\n\n    def _parse_search_result(self, book_div: Tag) -&gt; BookSearchResult | None:\n        \"\"\"\n        Parses a single book search result div into a BookSearchResult object.\n\n        Parameters\n        ----------\n        book_div : Tag\n            BeautifulSoup Tag for a single search result.\n\n        Returns\n        -------\n        BookSearchResult or None\n            Parsed result or None if data is incomplete.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = \"&lt;a class='capa-link-item' title='X' href='/livro/1-ed2'&gt;&lt;/a&gt;\"\n        &gt;&gt;&gt; service._parse_search_result(BeautifulSoup(html, 'html.parser'))\n        BookSearchResult(...)\n        \"\"\"\n        container = safe_find(book_div, \"a\", {\"class\": \"capa-link-item\"})\n        if not container:\n            logger.warning(\"Skipping book_div due to missing 'capa-link-item' container.\")\n            return None\n\n        title = get_tag_attr(container, \"title\")\n        book_url = f\"{self.base_url}{get_tag_attr(container, 'href')}\"\n        img_url = self._extract_img_url(container)\n        try:\n            book_id = int(get_book_id_from_url(book_url))\n            edition_id = int(get_book_edition_id_from_url(book_url))\n        except Exception:\n            logger.warning(f\"Skipping book_div due to invalid book/edition id in url: {book_url}\")\n            return None\n\n        publisher, isbn = self._extract_publisher_and_isbn(book_div)\n        rating = self._extract_rating(book_div, title)\n        return BookSearchResult(\n            edition_id=edition_id,\n            book_id=book_id,\n            title=title,\n            publisher=publisher,\n            isbn=isbn,\n            url=book_url,\n            cover_url=img_url,\n            rating=rating,\n        )\n\n    def _extract_img_url(self, container: Tag) -&gt; str:\n        \"\"\"\n        Extracts the image URL from the book cover container.\n\n        Parameters\n        ----------\n        container : Tag\n            BeautifulSoup Tag for the image container.\n\n        Returns\n        -------\n        str\n            URL of the book cover image or an empty string if not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = \"&lt;a&gt;&lt;img src='https://img.com/c.jpg'&gt;&lt;/a&gt;\"\n        &gt;&gt;&gt; service._extract_img_url(BeautifulSoup(html, 'html.parser').a)\n        'https://img.com/c.jpg'\n        \"\"\"\n        if container.img and isinstance(container.img, Tag):\n            src = get_tag_attr(container.img, \"src\")\n            if src and \"https\" in src:\n                return f\"https{src.split('https')[-1].strip()}\"\n        return \"\"\n\n    def _extract_publisher_and_isbn(self, book_div: Tag) -&gt; tuple[str | None, str | None]:\n        \"\"\"\n        Extracts publisher and ISBN information from a book search result div.\n\n        Parameters\n        ----------\n        book_div : Tag\n            BeautifulSoup Tag for the book search result.\n\n        Returns\n        -------\n        tuple of (str or None, str or None)\n            Publisher and ISBN string or None if not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = \"&lt;div class='detalhes-2-sub'&gt;&lt;div&gt;&lt;span&gt;Editora&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\"\n        &gt;&gt;&gt; service._extract_publisher_and_isbn(BeautifulSoup(html, 'html.parser'))\n        ('Editora', None)\n        \"\"\"\n        detalhes2sub = safe_find(book_div, \"div\", {\"class\": \"detalhes-2-sub\"})\n        detalhes2sub_div = detalhes2sub.div if detalhes2sub else None\n        spans = safe_find_all(detalhes2sub_div, \"span\") if detalhes2sub_div else []\n        cleaned_spans = [text for span in spans if (text := span.get_text(strip=True)) and text != \"|\"]\n        isbn_pattern = re.compile(r\"^\\d{9,13}$|^B0[A-Z0-9]{8,}$\")\n        isbn: str | None = None\n        publisher: str | None = None\n        if cleaned_spans:\n            if isbn_pattern.match(cleaned_spans[0]):\n                isbn = cleaned_spans[0]\n            if len(cleaned_spans) &gt; 1:\n                publisher = cleaned_spans[1]\n        return publisher, isbn\n\n    def _extract_rating(self, book_div: Tag, title: str) -&gt; float | None:\n        \"\"\"\n        Extracts the rating value from a search result div.\n\n        Parameters\n        ----------\n        book_div : Tag\n            BeautifulSoup Tag for the book search result.\n        title : str\n            Title of the book (for logging purposes).\n\n        Returns\n        -------\n        float or None\n            The rating or None if not found or parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; html = \"&lt;div class='star-mini'&gt;&lt;strong&gt;4,5&lt;/strong&gt;&lt;/div&gt;\"\n        &gt;&gt;&gt; service._extract_rating(BeautifulSoup(html, 'html.parser'), 'Example')\n        4.5\n        \"\"\"\n        star_mini = safe_find(book_div, \"div\", {\"class\": \"star-mini\"})\n        if star_mini:\n            strong_tag = safe_find(star_mini, \"strong\")\n            rating_text = get_tag_text(strong_tag)\n            if rating_text:\n                try:\n                    return float(rating_text.replace(\",\", \".\"))\n                except ValueError:\n                    logger.warning(f\"Could not parse rating '{rating_text}' for book '{title}'. Setting to None.\")\n        return None\n\n    def _extract_total_results(self, soup) -&gt; int:\n        \"\"\"\n        Extracts the total number of search results from the soup.\n\n        Parameters\n        ----------\n        soup : Tag\n            Parsed BeautifulSoup object of the search result page.\n\n        Returns\n        -------\n        int\n            Total number of results, or 0 if not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service._extract_total_results(BeautifulSoup(\"&lt;div class='contador'&gt;1 encontrados&lt;/div&gt;\", 'html.parser'))\n        1\n        \"\"\"\n        total_results_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n        if total_results_tag:\n            total_results_text = get_tag_text(total_results_tag)\n            match = re.search(r\"(\\d+)\\s+encontrados\", total_results_text)\n            if match:\n                return int(match.group(1))\n        return 0\n\n    def _clean_book_json_data(self, json_data: dict) -&gt; None:\n        \"\"\"\n        Cleans and normalizes the JSON data returned from the API before model validation.\n\n        Parameters\n        ----------\n        json_data : dict\n            Dictionary from the API response, modified in place.\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        &gt;&gt;&gt; data = {\"url\": \"/book\", \"isbn\": \"0\"}\n        &gt;&gt;&gt; service._clean_book_json_data(data)\n        &gt;&gt;&gt; data[\"cover_url\"]\n        ''\n        \"\"\"\n        json_data[\"url\"] = f\"{self.base_url}{json_data['url']}\"\n        json_data[\"isbn\"] = None if str(json_data.get(\"isbn\", \"0\")) == \"0\" else json_data[\"isbn\"]\n        json_data[\"autor\"] = None if json_data.get(\"autor\", \"\").lower() == \"n\u00e3o especificado\" else json_data[\"autor\"]\n        json_data[\"serie\"] = json_data.get(\"serie\") or None\n        json_data[\"volume\"] = None if not json_data.get(\"volume\") or str(json_data[\"volume\"]) == \"0\" else str(json_data[\"volume\"])\n        json_data[\"mes\"] = None if not json_data.get(\"mes\") or str(json_data[\"mes\"]).strip() == \"\" else json_data[\"mes\"]\n        img_url = json_data.get(\"img_url\", \"\")\n        json_data[\"cover_url\"] = f\"https{img_url.split('https')[-1].strip()}\" if img_url and \"https\" in img_url else \"\"\n        generos = json_data.get(\"generos\")\n        json_data[\"generos\"] = generos if generos else None\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_by_id","title":"<code>get_by_id(edition_id)</code>","text":"<p>Retrieves a book by its edition ID.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>Book</code> <p>Book object populated with detailed information.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no book is found with the given edition_id.</p> <code>ParsingError</code> <p>If parsing or HTTP errors occur.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).title\n'Some Book'\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_by_id(self, edition_id: int) -&gt; Book:\n    \"\"\"\n    Retrieves a book by its edition ID.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    Book\n        Book object populated with detailed information.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no book is found with the given edition_id.\n    ParsingError\n        If parsing or HTTP errors occur.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).title\n    'Some Book'\n    \"\"\"\n    logger.info(f\"Getting book by edition_id: {edition_id}\")\n    url = f\"{self.base_url}/v1/book/{edition_id}/stats:true\"\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        json_data = response.json().get(\"response\")\n        if not json_data:\n            cod_description = response.json().get(\"cod_description\", \"No description provided.\")\n            error_msg = f\"No data found for edition_id {edition_id}. Description: {cod_description}\"\n            logger.warning(error_msg)\n            raise FileNotFoundError(error_msg)\n        self._clean_book_json_data(json_data)\n        book = Book.model_validate(json_data)\n        logger.info(\n            \"Successfully retrieved book: '%s' (Edition ID: %s)\",\n            book.title,\n            edition_id,\n        )\n        return book\n    except FileNotFoundError:\n        raise\n    except Exception as e:\n        logger.error(\n            f\"Error retrieving book for edition_id {edition_id}: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(f\"Failed to retrieve book for edition_id {edition_id}.\") from e\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_reviews","title":"<code>get_reviews(book_id, edition_id=None, page=1)</code>","text":"<p>Retrieves reviews for a book.</p> <p>Parameters:</p> Name Type Description Default <code>book_id</code> <code>int</code> <p>Book ID for which to retrieve reviews.</p> required <code>edition_id</code> <code>int or None</code> <p>Specific edition ID, or auto-detected if None.</p> <code>None</code> <code>page</code> <code>int</code> <p>Page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookReview]</code> <p>A paginated list of reviews for the book.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes or parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_reviews(123).results\n[...]\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_reviews(self, book_id: int, edition_id: int | None = None, page: int = 1) -&gt; Pagination[BookReview]:\n    \"\"\"\n    Retrieves reviews for a book.\n\n    Parameters\n    ----------\n    book_id : int\n        Book ID for which to retrieve reviews.\n    edition_id : int or None, optional\n        Specific edition ID, or auto-detected if None.\n    page : int, optional\n        Page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookReview]\n        A paginated list of reviews for the book.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes or parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_reviews(123).results\n    [...]\n    \"\"\"\n    url = f\"{self.base_url}/livro/resenhas/{book_id}/mpage:{page}/limit:50\"\n    if edition_id:\n        url += f\"/edition:{edition_id}\"\n    logger.info(f\"Getting reviews for book_id: {book_id}, page: {page}\")\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        if edition_id is None:\n            edition_id = self._extract_edition_id_from_reviews_page(soup)\n        book_reviews = [\n            review\n            for review in (\n                self._parse_review(r, book_id, edition_id) for r in safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n            )\n            if review is not None\n        ]\n        next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError, TypeError) as e:\n        logger.error(f\"Failed to parse book reviews: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse book reviews.\") from e\n    except Exception as e:\n        logger.error(\n            f\"An unexpected error occurred during review fetching: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during review fetching.\") from e\n    logger.info(f\"Found {len(book_reviews)} reviews on page {page}.\")\n    return Pagination[BookReview](\n        results=book_reviews,\n        limit=50,\n        page=page,\n        total=len(book_reviews),\n        has_next_page=next_page_link is not None,\n    )\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.get_users_by_status","title":"<code>get_users_by_status(book_id, status, edition_id=None, limit=500, page=1)</code>","text":"<p>Retrieves users who have a book with a specific status.</p> <p>Parameters:</p> Name Type Description Default <code>book_id</code> <code>int</code> <p>The ID of the book.</p> required <code>status</code> <code>BookUserStatus</code> <p>The status of the book in the user's shelf.</p> required <code>edition_id</code> <code>int or None</code> <p>The edition ID of the book, by default None.</p> <code>None</code> <code>limit</code> <code>int</code> <p>The number of users to retrieve per page, by default 500.</p> <code>500</code> <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[int]</code> <p>A paginated list of user IDs.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n[1, 2, 3]\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def get_users_by_status(\n    self,\n    book_id: int,\n    status: BookUserStatus,\n    edition_id: int | None = None,\n    limit: int = 500,\n    page: int = 1,\n) -&gt; Pagination[int]:\n    \"\"\"\n    Retrieves users who have a book with a specific status.\n\n    Parameters\n    ----------\n    book_id : int\n        The ID of the book.\n    status : BookUserStatus\n        The status of the book in the user's shelf.\n    edition_id : int or None, optional\n        The edition ID of the book, by default None.\n    limit : int, optional\n        The number of users to retrieve per page, by default 500.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[int]\n        A paginated list of user IDs.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_users_by_status(1, BookUserStatus.READERS).results[:3]\n    [1, 2, 3]\n    \"\"\"\n    url = f\"{self.base_url}/livro/leitores/{status.value}/{book_id}/limit:{limit}/page:{page}\"\n    if edition_id:\n        url += f\"/edition:{edition_id}\"\n    logger.info(\n        \"Getting users for book_id: %s with status '%s' on page %s\",\n        book_id,\n        status.value,\n        page,\n    )\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        users_id = self._extract_user_ids_from_html(soup)\n        next_page_link = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError, TypeError) as e:\n        logger.error(f\"Failed to parse users by status: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse users by status.\") from e\n    except Exception as e:\n        logger.error(\n            \"An unexpected error occurred during user status fetching: %s\",\n            e,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during user status fetching.\") from e\n    logger.info(\n        \"Found %s users on page %s.\",\n        len(users_id),\n        page,\n    )\n    return Pagination[int](\n        results=users_id,\n        limit=limit,\n        page=page,\n        total=len(users_id),\n        has_next_page=next_page_link is not None,\n    )\n</code></pre>"},{"location":"books_service/#pyskoob.books.BookService.search","title":"<code>search(query, search_by=BookSearch.TITLE, page=1)</code>","text":"<p>Searches for books by query and type.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query string.</p> required <code>search_by</code> <code>BookSearch</code> <p>The type of search (title, author, etc.), by default <code>BookSearch.TITLE</code>.</p> <code>TITLE</code> <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookSearchResult]</code> <p>A paginated list of search results.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"Duna\").results[0].title\n'Duna'\n</code></pre> Source code in <code>pyskoob/books.py</code> <pre><code>def search(\n    self,\n    query: str,\n    search_by: BookSearch = BookSearch.TITLE,\n    page: int = 1,\n) -&gt; Pagination[BookSearchResult]:\n    \"\"\"\n    Searches for books by query and type.\n\n    Parameters\n    ----------\n    query : str\n        The search query string.\n    search_by : BookSearch, optional\n        The type of search (title, author, etc.), by default\n        ``BookSearch.TITLE``.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookSearchResult]\n        A paginated list of search results.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"Duna\").results[0].title\n    'Duna'\n    \"\"\"\n    url = f\"{self.base_url}/livro/lista/busca:{query}/tipo:{search_by.value}/mpage:{page}\"\n    logger.info(f\"Searching for books with query: '{query}' on page {page}\")\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n\n        limit = 30\n        results: list[BookSearchResult | None] = [\n            self._parse_search_result(book_div) for book_div in safe_find_all(soup, \"div\", {\"class\": \"box_lista_busca_vertical\"})\n        ]\n        cleaned_results: list[BookSearchResult] = [i for i in results if i]\n\n        total_results = self._extract_total_results(soup)\n        next_page_link = True if page * limit &lt; total_results else False\n    except (AttributeError, ValueError, IndexError, TypeError) as e:\n        logger.error(f\"Failed to parse book search results: {e}\", exc_info=True)\n        raise ParsingError(\"Failed to parse book search results.\") from e\n    except Exception as e:\n        logger.error(\n            f\"An unexpected error occurred during book search: {e}\",\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred during book search.\") from e\n\n    logger.info(\n        \"Found %s books on page %s, total %s results.\",\n        len(results),\n        page,\n        total_results,\n    )\n    return Pagination[BookSearchResult](\n        results=cleaned_results,\n        limit=30,\n        page=page,\n        total=total_results,\n        has_next_page=next_page_link,\n    )\n</code></pre>"},{"location":"contributing/","title":"Contributing Guide","text":"<p>Thank you for wanting to contribute to PySkoob! The following guidelines will help you open good issues and pull requests.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Search the existing issues to avoid duplicates.</li> <li>Provide clear steps to reproduce the problem and describe what you expected to happen.</li> <li>Include logs, stack traces and your environment information when applicable.</li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ol> <li>Fork the repository and create a new branch from <code>main</code>.</li> <li>Keep your changes focused on a single topic or feature.</li> <li>Write descriptive commit messages and link your PR to an open issue when possible.</li> <li>Make sure tests pass locally before submitting the PR.</li> </ol>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"<pre><code># Install uv (once)\n# pipx install uv\n\n# Create a virtual environment with uv\nuv venv .venv\nsource .venv/bin/activate\n\n# Install dependencies in editable mode\nuv pip install -e .[dev]\n\n# Install pre-commit hooks\npre-commit install\n\n# Run all checks\npre-commit run --all-files\n</code></pre> <p>Run <code>pre-commit run --all-files</code> to ensure formatting, linting and tests pass locally. The CI workflow runs the same hooks to verify submitted changes.</p> <p>Open your PR on GitHub and fill in a brief summary of your changes. A maintainer will review it as soon as possible.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":"<ul> <li>Adhere to PEP 8 and keep lines under 140 characters.</li> <li>Run <code>ruff --fix</code> to format and lint the codebase.</li> <li>Provide type hints and docstrings for all public modules, classes, and functions.</li> </ul>"},{"location":"contributing/#commit-message-format","title":"Commit Message Format","text":"<p>This project follows the Conventional Commits specification.</p> <ul> <li>Use the structure <code>&lt;type&gt;: &lt;short description&gt;</code> in the imperative mood.</li> <li>Common types include <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>refactor</code>, <code>test</code>, and <code>chore</code>.</li> <li>Limit the first line to 72 characters and reference issues when relevant, e.g., <code>fix: handle edge case (#123)</code>.</li> </ul>"},{"location":"contributing/#best-practices","title":"Best Practices","text":"<ul> <li>Review the coding standards and commit message format above before submitting your work.</li> <li>Add tests for any new functionality.</li> <li>Update documentation whenever behavior changes.</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>To build and preview the documentation locally:</p> <pre><code>uv pip install -e .[docs]\nmkdocs build --strict\nmkdocs serve\n</code></pre> <p>The build step validates links and outputs the site to the <code>site/</code> directory.</p>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>To publish a new version and deploy documentation:</p> <p>Ensure <code>PYPI_API_TOKEN</code> is stored in the repository secrets and GitHub Pages is enabled for the <code>gh-pages</code> branch before triggering the workflow.</p> <ol> <li>Trigger the Release workflow from the GitHub Actions tab.</li> <li>Choose the desired semantic version bump (<code>patch</code>, <code>minor</code>, or <code>major</code>).</li> <li>The workflow will bump the version, tag the commit, publish to PyPI, build the documentation, and push it to GitHub Pages.</li> </ol>"},{"location":"profile_service/","title":"Profile Service","text":"<p>The <code>SkoobProfileService</code> lets you modify your Skoob profile by labeling, shelving and rating books.</p>"},{"location":"profile_service/#example","title":"Example","text":"<pre><code>import os\nfrom pyskoob import SkoobClient\nfrom pyskoob.models.enums import BookStatus\n\nwith SkoobClient() as client:\n    client.auth.login(\n        email=os.getenv(\"SKOOB_EMAIL\"),\n        password=os.getenv(\"SKOOB_PASSWORD\"),\n    )\n    client.profile.update_book_status(10, BookStatus.READ)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService","title":"<code>SkoobProfileService</code>","text":"<p>               Bases: <code>AuthenticatedService</code></p> <p>Perform profile-related actions such as labeling and rating books.</p> Source code in <code>pyskoob/profile.py</code> <pre><code>class SkoobProfileService(AuthenticatedService):\n    \"\"\"Perform profile-related actions such as labeling and rating books.\"\"\"\n\n    def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n        \"\"\"Initialize the service with dependencies.\n\n        This service requires an authenticated session via\n        :class:`AuthService` and is typically used alongside\n        :class:`UserService` when manipulating the logged user's bookshelf\n        and other profile metadata.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n        auth_service : AuthService\n            The authentication service.\n        \"\"\"\n        super().__init__(client, auth_service)\n\n    def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n        \"\"\"\n        Adds a label to a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        label : BookLabel\n            The label to add.\n\n        Returns\n        -------\n        bool\n            True if the label was added successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def remove_book_label(self, edition_id: int) -&gt; bool:\n        \"\"\"\n        Removes a label from a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        bool\n            True if the label was removed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.remove_book_label(10)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n        \"\"\"\n        Updates the status of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        status : BookStatus\n            The new status for the book.\n\n        Returns\n        -------\n        bool\n            True if the status was updated successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def remove_book_status(self, edition_id: int) -&gt; bool:\n        \"\"\"\n        Removes the status of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n\n        Returns\n        -------\n        bool\n            True if the status was removed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.remove_book_status(10)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n        \"\"\"\n        Changes the bookshelf of a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        bookshelf : BookShelf\n            The new bookshelf for the book.\n\n        Returns\n        -------\n        bool\n            True if the bookshelf was changed successfully, False otherwise.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\n        True\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n        return response.json().get(\"success\", False)\n\n    def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n        \"\"\"\n        Rates a book.\n\n        Parameters\n        ----------\n        edition_id : int\n            The edition ID of the book.\n        ranking : float\n            The rating to give to the book (from 0 to 5).\n\n        Returns\n        -------\n        bool\n            True if the book was rated successfully.\n\n        Raises\n        ------\n        ValueError\n            If the rating is not between 0 and 5.\n        RuntimeError\n            If it fails to rate the book.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.rate_book(10, 4.5)\n        True\n        \"\"\"\n        self._validate_login()\n        if not (0 &lt;= ranking &lt;= 5):\n            raise ValueError(\"Rating must be between 0 and 5.\")\n\n        url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        if not response.json().get(\"success\"):\n            raise RuntimeError(\"Failed to rate the book.\")\n        return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.__init__","title":"<code>__init__(client, auth_service)</code>","text":"<p>Initialize the service with dependencies.</p> <p>This service requires an authenticated session via :class:<code>AuthService</code> and is typically used alongside :class:<code>UserService</code> when manipulating the logged user's bookshelf and other profile metadata.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <code>auth_service</code> <code>AuthService</code> <p>The authentication service.</p> required Source code in <code>pyskoob/profile.py</code> <pre><code>def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n    \"\"\"Initialize the service with dependencies.\n\n    This service requires an authenticated session via\n    :class:`AuthService` and is typically used alongside\n    :class:`UserService` when manipulating the logged user's bookshelf\n    and other profile metadata.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n    auth_service : AuthService\n        The authentication service.\n    \"\"\"\n    super().__init__(client, auth_service)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.add_book_label","title":"<code>add_book_label(edition_id, label)</code>","text":"<p>Adds a label to a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>label</code> <code>BookLabel</code> <p>The label to add.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was added successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def add_book_label(self, edition_id: int, label: BookLabel) -&gt; bool:\n    \"\"\"\n    Adds a label to a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    label : BookLabel\n        The label to add.\n\n    Returns\n    -------\n    bool\n        True if the label was added successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.add_book_label(10, BookLabel.FAVORITE)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/label_add/{edition_id}/{label.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.change_book_shelf","title":"<code>change_book_shelf(edition_id, bookshelf)</code>","text":"<p>Changes the bookshelf of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>bookshelf</code> <code>BookShelf</code> <p>The new bookshelf for the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the bookshelf was changed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def change_book_shelf(self, edition_id: int, bookshelf: BookShelf) -&gt; bool:\n    \"\"\"\n    Changes the bookshelf of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    bookshelf : BookShelf\n        The new bookshelf for the book.\n\n    Returns\n    -------\n    bool\n        True if the bookshelf was changed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.change_book_shelf(10, BookShelf.FAVORITES)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/estante/prateleira/{edition_id}/{bookshelf.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.rate_book","title":"<code>rate_book(edition_id, ranking)</code>","text":"<p>Rates a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>ranking</code> <code>float</code> <p>The rating to give to the book (from 0 to 5).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the book was rated successfully.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the rating is not between 0 and 5.</p> <code>RuntimeError</code> <p>If it fails to rate the book.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.rate_book(10, 4.5)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def rate_book(self, edition_id: int, ranking: float) -&gt; bool:\n    \"\"\"\n    Rates a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    ranking : float\n        The rating to give to the book (from 0 to 5).\n\n    Returns\n    -------\n    bool\n        True if the book was rated successfully.\n\n    Raises\n    ------\n    ValueError\n        If the rating is not between 0 and 5.\n    RuntimeError\n        If it fails to rate the book.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.rate_book(10, 4.5)\n    True\n    \"\"\"\n    self._validate_login()\n    if not (0 &lt;= ranking &lt;= 5):\n        raise ValueError(\"Rating must be between 0 and 5.\")\n\n    url = f\"{self.base_url}/v1/book_rate/{edition_id}/{ranking}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    if not response.json().get(\"success\"):\n        raise RuntimeError(\"Failed to rate the book.\")\n    return True\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.remove_book_label","title":"<code>remove_book_label(edition_id)</code>","text":"<p>Removes a label from a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was removed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.remove_book_label(10)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def remove_book_label(self, edition_id: int) -&gt; bool:\n    \"\"\"\n    Removes a label from a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    bool\n        True if the label was removed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.remove_book_label(10)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/label_del/{edition_id}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.remove_book_status","title":"<code>remove_book_status(edition_id)</code>","text":"<p>Removes the status of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the status was removed successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.remove_book_status(10)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def remove_book_status(self, edition_id: int) -&gt; bool:\n    \"\"\"\n    Removes the status of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n\n    Returns\n    -------\n    bool\n        True if the status was removed successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.remove_book_status(10)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_del/{edition_id}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"profile_service/#pyskoob.profile.SkoobProfileService.update_book_status","title":"<code>update_book_status(edition_id, status)</code>","text":"<p>Updates the status of a book.</p> <p>Parameters:</p> Name Type Description Default <code>edition_id</code> <code>int</code> <p>The edition ID of the book.</p> required <code>status</code> <code>BookStatus</code> <p>The new status for the book.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the status was updated successfully, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\nTrue\n</code></pre> Source code in <code>pyskoob/profile.py</code> <pre><code>def update_book_status(self, edition_id: int, status: BookStatus) -&gt; bool:\n    \"\"\"\n    Updates the status of a book.\n\n    Parameters\n    ----------\n    edition_id : int\n        The edition ID of the book.\n    status : BookStatus\n        The new status for the book.\n\n    Returns\n    -------\n    bool\n        True if the status was updated successfully, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.update_book_status(10, BookStatus.READ)\n    True\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/shelf_add/{edition_id}/{status.value}\"\n    response = self.client.get(url)\n    response.raise_for_status()\n    return response.json().get(\"success\", False)\n</code></pre>"},{"location":"publishers_service/","title":"Publisher Service","text":"<p>The <code>PublisherService</code> fetches information about publishers and their releases on Skoob.</p>"},{"location":"publishers_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    publisher = client.publishers.get_by_id(21)  # replace with a real id\n    print(publisher.name)\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService","title":"<code>PublisherService</code>","text":"<p>               Bases: <code>BaseSkoobService</code></p> <p>High level operations for retrieving publishers.</p> Source code in <code>pyskoob/publishers.py</code> <pre><code>class PublisherService(BaseSkoobService):\n    \"\"\"High level operations for retrieving publishers.\"\"\"\n\n    def get_by_id(self, publisher_id: int) -&gt; Publisher:\n        \"\"\"Retrieve detailed information about a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n\n        Returns\n        -------\n        Publisher\n            An object containing information about the publisher, including\n            statistics and recently released books.\n\n        Raises\n        ------\n        ParsingError\n            If the expected elements cannot be parsed from the page.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).name\n        'Editora Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/{publisher_id}\"\n        logger.info(\"Fetching publisher page: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n            description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n            site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n            website = get_tag_attr(site_link, \"href\")\n            stats = self._parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n            releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n            releases = [self._parse_book(div) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n            return Publisher(\n                id=publisher_id,\n                name=name,\n                description=description,\n                website=website,\n                stats=stats,\n                last_releases=releases,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:\n            logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher page.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher page: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n\n    def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n        \"\"\"Retrieve authors associated with a publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            The pagination page to retrieve, by default 1.\n\n        Returns\n        -------\n        Pagination[PublisherAuthor]\n            A paginated list of authors published by the publisher.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure for authors cannot be parsed.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_authors(1).results[0].name\n        'Autor Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher authors: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            authors = [self._parse_author(div) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=authors,\n                limit=len(authors),\n                page=page,\n                total=len(authors),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:\n            logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher authors.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher authors: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n\n    def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n        \"\"\"Retrieve books published by the publisher.\n\n        Parameters\n        ----------\n        publisher_id : int\n            The identifier of the publisher on Skoob.\n        page : int, optional\n            The pagination page to retrieve, by default 1.\n\n        Returns\n        -------\n        Pagination[PublisherItem]\n            A paginated list of books released by the publisher.\n\n        Raises\n        ------\n        ParsingError\n            If book elements cannot be parsed from the page.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_books(1).results[0].title\n        'Livro Exemplo'\n        \"\"\"\n        url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n        logger.info(\"Fetching publisher books: %s\", url)\n        try:\n            response = self.client.get(url)\n            response.raise_for_status()\n            soup = self.parse_html(response.text)\n            books = [self._parse_book(div) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n            next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n            return Pagination(\n                results=books,\n                limit=len(books),\n                page=page,\n                total=len(books),\n                has_next_page=next_page,\n            )\n        except (AttributeError, TypeError, ValueError) as exc:\n            logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n            raise ParsingError(\"Failed to parse publisher books.\") from exc\n        except Exception as exc:  # pragma: no cover - unexpected\n            logger.error(\n                \"An unexpected error occurred while parsing publisher books: %s\",\n                exc,\n                exc_info=True,\n            )\n            raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n\n    # Helpers\n    def _parse_stats(self, div: Tag | None) -&gt; PublisherStats:\n        if not div:\n            return PublisherStats()\n        followers = None\n        avg = None\n        ratings = None\n        male = None\n        female = None\n        seg_span = div.find(\"span\", string=lambda text: bool(text and \"Seguidor\" in text))\n        if seg_span:\n            followers_text = get_tag_text(seg_span.find_next(\"span\")).replace(\".\", \"\")\n            followers = int(followers_text) if followers_text.isdigit() else None\n        aval_span = div.find(\"span\", string=lambda text: bool(text and \"Avalia\" in text))\n        if aval_span:\n            rating_info = get_tag_text(aval_span.find_next(\"span\"))\n            if \"/\" in rating_info:\n                rating_part, total_part = (p.strip() for p in rating_info.split(\"/\"))\n                avg = float(rating_part.replace(\",\", \".\")) if rating_part else None\n                clean_total = total_part.replace(\".\", \"\")\n                ratings = int(clean_total) if clean_total.isdigit() else None\n        male_icon = div.find(\"i\", {\"class\": \"icon-male\"})\n        if male_icon:\n            male_text = get_tag_text(male_icon.find_next(\"span\")).replace(\"%\", \"\")\n            male = int(male_text) if male_text.isdigit() else None\n        female_icon = div.find(\"i\", {\"class\": \"icon-female\"})\n        if female_icon:\n            female_text = get_tag_text(female_icon.find_next(\"span\")).replace(\"%\", \"\")\n            female = int(female_text) if female_text.isdigit() else None\n        return PublisherStats(\n            followers=followers,\n            average_rating=avg,\n            ratings=ratings,\n            male_percentage=male,\n            female_percentage=female,\n        )\n\n    def _parse_book(self, div: Tag) -&gt; PublisherItem:\n        anchor = safe_find(div, \"a\")\n        img_tag = safe_find(anchor, \"img\")\n        return PublisherItem(\n            url=f\"{self.base_url}{get_tag_attr(anchor, 'href')}\",\n            title=get_tag_attr(anchor, \"title\"),\n            img_url=get_tag_attr(img_tag, \"src\"),\n        )\n\n    def _parse_author(self, div: Tag) -&gt; PublisherAuthor:\n        anchor = safe_find(div, \"a\")\n        name_tag = safe_find(div, \"h3\")\n        img_tag = safe_find(anchor, \"img\")\n        return PublisherAuthor(\n            url=f\"{self.base_url}{get_tag_attr(anchor, 'href')}\",\n            name=get_tag_text(name_tag),\n            img_url=get_tag_attr(img_tag, \"src\"),\n        )\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_authors","title":"<code>get_authors(publisher_id, page=1)</code>","text":"<p>Retrieve authors associated with a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>The pagination page to retrieve, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherAuthor]</code> <p>A paginated list of authors published by the publisher.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure for authors cannot be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_authors(1).results[0].name\n'Autor Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_authors(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherAuthor]:\n    \"\"\"Retrieve authors associated with a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        The pagination page to retrieve, by default 1.\n\n    Returns\n    -------\n    Pagination[PublisherAuthor]\n        A paginated list of authors published by the publisher.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure for authors cannot be parsed.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_authors(1).results[0].name\n    'Autor Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/autores/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher authors: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        authors = [self._parse_author(div) for div in safe_find_all(soup, \"div\", {\"class\": \"box_autor\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=authors,\n            limit=len(authors),\n            page=page,\n            total=len(authors),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:\n        logger.error(\"Failed to parse publisher authors: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher authors.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher authors: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher authors.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_books","title":"<code>get_books(publisher_id, page=1)</code>","text":"<p>Retrieve books published by the publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <code>page</code> <code>int</code> <p>The pagination page to retrieve, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[PublisherItem]</code> <p>A paginated list of books released by the publisher.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If book elements cannot be parsed from the page.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_books(1).results[0].title\n'Livro Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_books(self, publisher_id: int, page: int = 1) -&gt; Pagination[PublisherItem]:\n    \"\"\"Retrieve books published by the publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n    page : int, optional\n        The pagination page to retrieve, by default 1.\n\n    Returns\n    -------\n    Pagination[PublisherItem]\n        A paginated list of books released by the publisher.\n\n    Raises\n    ------\n    ParsingError\n        If book elements cannot be parsed from the page.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_books(1).results[0].title\n    'Livro Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/livros/{publisher_id}/mpage:{page}\"\n    logger.info(\"Fetching publisher books: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        books = [self._parse_book(div) for div in safe_find_all(soup, \"div\", {\"class\": \"box_livro\"})]\n        next_page = bool(safe_find(soup, \"div\", {\"class\": \"proximo\"}))\n        return Pagination(\n            results=books,\n            limit=len(books),\n            page=page,\n            total=len(books),\n            has_next_page=next_page,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:\n        logger.error(\"Failed to parse publisher books: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher books.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher books: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher books.\") from exc\n</code></pre>"},{"location":"publishers_service/#pyskoob.publishers.PublisherService.get_by_id","title":"<code>get_by_id(publisher_id)</code>","text":"<p>Retrieve detailed information about a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>publisher_id</code> <code>int</code> <p>The identifier of the publisher on Skoob.</p> required <p>Returns:</p> Type Description <code>Publisher</code> <p>An object containing information about the publisher, including statistics and recently released books.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the expected elements cannot be parsed from the page.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).name\n'Editora Exemplo'\n</code></pre> Source code in <code>pyskoob/publishers.py</code> <pre><code>def get_by_id(self, publisher_id: int) -&gt; Publisher:\n    \"\"\"Retrieve detailed information about a publisher.\n\n    Parameters\n    ----------\n    publisher_id : int\n        The identifier of the publisher on Skoob.\n\n    Returns\n    -------\n    Publisher\n        An object containing information about the publisher, including\n        statistics and recently released books.\n\n    Raises\n    ------\n    ParsingError\n        If the expected elements cannot be parsed from the page.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).name\n    'Editora Exemplo'\n    \"\"\"\n    url = f\"{self.base_url}/editora/{publisher_id}\"\n    logger.info(\"Fetching publisher page: %s\", url)\n    try:\n        response = self.client.get(url)\n        response.raise_for_status()\n        soup = self.parse_html(response.text)\n        name = get_tag_text(safe_find(soup, \"h2\")) or get_tag_text(soup.title)\n        description = get_tag_text(safe_find(soup, \"div\", {\"id\": \"historico\"}))\n        site_link = cast(Tag | None, soup.find(\"a\", string=\"Site oficial\"))\n        website = get_tag_attr(site_link, \"href\")\n        stats = self._parse_stats(safe_find(soup, \"div\", {\"id\": \"vt_estatisticas\"}))\n        releases_div = safe_find(soup, \"div\", {\"id\": \"livros_lancamentos\"})\n        releases = [self._parse_book(div) for div in safe_find_all(releases_div, \"div\", {\"class\": \"livro-capa-mini\"})]\n        return Publisher(\n            id=publisher_id,\n            name=name,\n            description=description,\n            website=website,\n            stats=stats,\n            last_releases=releases,\n        )\n    except (AttributeError, TypeError, ValueError) as exc:\n        logger.error(\"Failed to parse publisher page: %s\", exc, exc_info=True)\n        raise ParsingError(\"Failed to parse publisher page.\") from exc\n    except Exception as exc:  # pragma: no cover - unexpected\n        logger.error(\n            \"An unexpected error occurred while parsing publisher page: %s\",\n            exc,\n            exc_info=True,\n        )\n        raise ParsingError(\"An unexpected error occurred while parsing publisher page.\") from exc\n</code></pre>"},{"location":"stable_api/","title":"Stable Public API","text":"<p>The following classes and functions are considered stable. They are re-exported from the :mod:<code>pyskoob</code> package and will only change with a deprecation period. You can import them directly from the package root:</p> <pre><code>from pyskoob import SkoobClient, HttpxSyncClient\n</code></pre> <ul> <li><code>SkoobClient</code></li> <li><code>AuthService</code></li> <li><code>BookService</code></li> <li><code>AuthorService</code></li> <li><code>UserService</code></li> <li><code>SkoobProfileService</code></li> <li><code>PublisherService</code></li> <li><code>HttpxSyncClient</code></li> <li><code>HttpxAsyncClient</code></li> </ul> <p>Anything not listed above should be treated as internal and may change without notice.</p>"},{"location":"users_service/","title":"Users Service","text":"<p>The <code>UserService</code> searches and retrieves Skoob user profiles.</p>"},{"location":"users_service/#example","title":"Example","text":"<pre><code>from pyskoob import SkoobClient\n\nwith SkoobClient() as client:\n    # TIP: use environment variables or a secrets manager instead of hard-coding credentials\n    client.auth.login(email=\"you@example.com\", password=\"secret\")\n    results = client.users.search(\"victor\")\n    for user in results.results:\n        print(user.name, user.id)\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService","title":"<code>UserService</code>","text":"<p>               Bases: <code>AuthenticatedService</code></p> <p>Fetch user profiles, books and friends from Skoob.</p> Source code in <code>pyskoob/users.py</code> <pre><code>class UserService(AuthenticatedService):\n    \"\"\"Fetch user profiles, books and friends from Skoob.\"\"\"\n\n    def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n        \"\"\"Initialize the service with dependencies.\n\n        The service depends on :class:`AuthService` to validate the current\n        session before performing operations that require authentication such\n        as retrieving your own profile or editing bookshelf information.\n\n        Parameters\n        ----------\n        client : SyncHTTPClient\n            The HTTP client to use for requests.\n        auth_service : AuthService\n            The authentication service.\n        \"\"\"\n        super().__init__(client, auth_service)\n\n    def get_by_id(self, user_id: int) -&gt; User:\n        \"\"\"\n        Retrieves a user by their ID.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        User\n            The user's information.\n\n        Raises\n        ------\n        FileNotFoundError\n            If the user with the given ID is not found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_by_id(1).name\n        'Example'\n        \"\"\"\n        self._validate_login()\n        logger.info(f\"Getting user by id: {user_id}\")\n        url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        if not json_data.get(\"success\"):\n            logger.warning(f\"User with ID {user_id} not found.\")\n            raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n\n        user_data = json_data[\"response\"]\n        user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n        user = User.model_validate(user_data)\n        logger.info(f\"Successfully retrieved user: '{user.name}'\")\n        return user\n\n    def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n        \"\"\"\n        Retrieves a user's relations (friends, followers, following).\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        relation : UsersRelation\n            The type of relation to retrieve.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[int]\n            A paginated list of user IDs.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n        [2, 3]\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n        logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        soup = self.parse_html(response.text)\n        try:\n            users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n            users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n            next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n        except (AttributeError, ValueError, IndexError) as e:\n            logger.error(f\"Failed to parse user relations: {e}\")\n            raise ParsingError(\"Failed to parse user relations.\") from e\n\n        logger.info(f\"Found {len(users_id)} users on page {page}.\")\n        return Pagination(\n            results=users_id,\n            limit=100,\n            page=page,\n            total=len(users_id),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page_link),\n        )\n\n    def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n        \"\"\"\n        Retrieves reviews made by a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[BookReview]\n            A paginated list of book reviews.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure of the page changes and parsing fails.\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n        logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        user_reviews = []\n        soup = self.parse_html(response.text)\n        try:\n            reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n            for review_elem in reviews_html:\n                review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n                book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n                book_url = get_tag_attr(book_anchor, \"href\")\n                book_id = int(get_book_id_from_url(book_url))\n                edition_id = int(get_book_edition_id_from_url(book_url))\n                star_rating = safe_find(review_elem, \"star-rating\")\n                rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n                comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n                date_str = get_tag_text(safe_find(comment, \"span\"))\n                date = None\n                if date_str:\n                    try:\n                        date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                    except ValueError:\n                        date = None\n                review_text = \"\"\n                if comment:\n                    span = safe_find(comment, \"span\")\n                    if span:\n                        siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                        review_text = \"\\n\".join(siblings).strip()\n                user_reviews.append(\n                    BookReview(\n                        review_id=review_id,\n                        book_id=book_id,\n                        edition_id=edition_id,\n                        user_id=user_id,\n                        rating=rating,\n                        review_text=review_text,\n                        reviewed_at=date,\n                    )\n                )\n            next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n        except (AttributeError, ValueError, IndexError) as e:\n            logger.error(f\"Failed to parse user reviews: {e}\")\n            raise ParsingError(\"Failed to parse user reviews.\") from e\n\n        logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n        return Pagination(\n            results=user_reviews,\n            limit=50,\n            page=page,\n            total=len(user_reviews),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page_link),\n        )\n\n    def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n        \"\"\"\n        Retrieves reading statistics for a user.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n\n        Returns\n        -------\n        UserReadStats\n            The user's reading statistics.\n        \"\"\"\n        self._validate_login()\n        logger.info(f\"Getting read stats for user_id: {user_id}\")\n        url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json().get(\"response\", {})\n\n        stats = UserReadStats(\n            user_id=user_id,\n            year=json_data.get(\"ano\"),\n            books_read=json_data.get(\"lido\"),\n            pages_read=json_data.get(\"paginas_lidas\"),\n            total_pages=json_data.get(\"paginas_total\"),\n            percent_complete=json_data.get(\"percentual_lido\"),\n            books_total=json_data.get(\"total\"),\n            reading_speed=json_data.get(\"velocidade_dia\"),\n            ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n        )\n        logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n        return stats\n\n    def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n        \"\"\"\n        Retrieves a user's bookcase.\n\n        Parameters\n        ----------\n        user_id : int\n            The ID of the user.\n        bookcase_option : BookcaseOption\n            The type of bookcase to retrieve.\n        page : int, optional\n            The page number for pagination, by default 1.\n\n        Returns\n        -------\n        Pagination[UserBook]\n            A paginated list of books in the user's bookcase.\n        \"\"\"\n        self._validate_login()\n        url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n        logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        json_data = response.json()\n        next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n        results = []\n        for r in json_data.get(\"response\", []):\n            edicao = r.get(\"edicao\", {})\n            results.append(\n                UserBook(\n                    user_id=user_id,\n                    book_id=edicao.get(\"livro_id\"),\n                    edition_id=edicao.get(\"id\"),\n                    rating=r.get(\"ranking\"),\n                    is_favorite=r.get(\"favorito\"),\n                    is_wishlist=r.get(\"desejado\"),\n                    is_tradable=r.get(\"troco\"),\n                    is_owned=r.get(\"tenho\"),\n                    is_loaned=r.get(\"emprestei\"),\n                    reading_goal_year=r.get(\"meta\"),\n                    pages_read=r.get(\"paginas_lidas\"),\n                )\n            )\n\n        logger.info(f\"Found {len(results)} books on page {page}.\")\n        return Pagination(\n            limit=100,\n            results=results,\n            total=len(results),  # Placeholder, actual total is not easily available\n            has_next_page=bool(next_page),\n            page=page,\n        )\n\n    def search(\n        self,\n        query: str,\n        gender: UserGender | None = None,\n        state: BrazilianState | None = None,\n        page: int = 1,\n        limit: int = 100,\n    ) -&gt; Pagination[UserSearch]:\n        \"\"\"Search for users on Skoob.\n\n        Parameters\n        ----------\n        query : str\n            The search query for usernames or names.\n        gender : UserGender, optional\n            Optional gender filter (M/F), by default ``None``.\n        state : BrazilianState, optional\n            Optional state filter (e.g., ``SP``), by default ``None``.\n        page : int, optional\n            Page number to fetch, by default ``1``.\n        limit : int, optional\n            Number of users per page, by default ``100``.\n\n        Returns\n        -------\n        Pagination[UserSearch]\n            A paginated list of users matching the criteria.\n\n        Raises\n        ------\n        ParsingError\n            If the HTML structure is invalid or parsing fails.\n\n        Examples\n        --------\n        &gt;&gt;&gt; service.search(\"example\").page\n        1\n        \"\"\"\n        self._validate_login()\n\n        url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n        if gender:\n            url += f\"/sexo:{gender.value}\"\n        if state:\n            url += f\"/uf:{state.value}\"\n\n        response = self.client.get(url)\n        response.raise_for_status()\n\n        soup = BeautifulSoup(response.text, \"html.parser\")\n\n        try:\n            user_divs = safe_find_all(\n                soup,\n                \"div\",\n                attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n            )\n            results: list[UserSearch] = []\n\n            for div in user_divs:\n                anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n                if not anchor:\n                    continue\n\n                href = get_tag_attr(anchor, \"href\")\n                full_url = f\"{self.base_url}{href}\"\n                match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n                if not match:\n                    continue\n\n                user_id = int(match.group(1))\n                username = match.group(2)\n                name = get_tag_text(anchor)\n\n                logger.debug(\n                    \"User ID: %s / Username: %s / Name: %s / URL: %s\",\n                    user_id,\n                    username,\n                    name,\n                    full_url,\n                )\n\n                results.append(\n                    UserSearch(\n                        id=user_id,\n                        username=username,\n                        name=name,\n                        url=full_url,\n                    )\n                )\n\n            total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n            total_text = get_tag_text(total_tag)\n            total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n\n            next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n            has_next = next_page is not None\n\n            return Pagination[UserSearch](\n                results=results,\n                page=page,\n                total=total,\n                limit=limit,\n                has_next_page=has_next,\n            )\n\n        except Exception as e:\n            raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.__init__","title":"<code>__init__(client, auth_service)</code>","text":"<p>Initialize the service with dependencies.</p> <p>The service depends on :class:<code>AuthService</code> to validate the current session before performing operations that require authentication such as retrieving your own profile or editing bookshelf information.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>SyncHTTPClient</code> <p>The HTTP client to use for requests.</p> required <code>auth_service</code> <code>AuthService</code> <p>The authentication service.</p> required Source code in <code>pyskoob/users.py</code> <pre><code>def __init__(self, client: SyncHTTPClient, auth_service: AuthService):\n    \"\"\"Initialize the service with dependencies.\n\n    The service depends on :class:`AuthService` to validate the current\n    session before performing operations that require authentication such\n    as retrieving your own profile or editing bookshelf information.\n\n    Parameters\n    ----------\n    client : SyncHTTPClient\n        The HTTP client to use for requests.\n    auth_service : AuthService\n        The authentication service.\n    \"\"\"\n    super().__init__(client, auth_service)\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_bookcase","title":"<code>get_bookcase(user_id, bookcase_option, page=1)</code>","text":"<p>Retrieves a user's bookcase.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>bookcase_option</code> <code>BookcaseOption</code> <p>The type of bookcase to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[UserBook]</code> <p>A paginated list of books in the user's bookcase.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_bookcase(self, user_id: int, bookcase_option: BookcaseOption, page: int = 1) -&gt; Pagination[UserBook]:\n    \"\"\"\n    Retrieves a user's bookcase.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    bookcase_option : BookcaseOption\n        The type of bookcase to retrieve.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[UserBook]\n        A paginated list of books in the user's bookcase.\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/v1/bookcase/books/{user_id}/shelf_id:{bookcase_option.value}/page:{page}/limit:100\"\n    logger.info(f\"Getting bookcase for user_id: {user_id}, option: '{bookcase_option.name}', page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    next_page = json_data.get(\"paging\", {}).get(\"next_page\")\n    results = []\n    for r in json_data.get(\"response\", []):\n        edicao = r.get(\"edicao\", {})\n        results.append(\n            UserBook(\n                user_id=user_id,\n                book_id=edicao.get(\"livro_id\"),\n                edition_id=edicao.get(\"id\"),\n                rating=r.get(\"ranking\"),\n                is_favorite=r.get(\"favorito\"),\n                is_wishlist=r.get(\"desejado\"),\n                is_tradable=r.get(\"troco\"),\n                is_owned=r.get(\"tenho\"),\n                is_loaned=r.get(\"emprestei\"),\n                reading_goal_year=r.get(\"meta\"),\n                pages_read=r.get(\"paginas_lidas\"),\n            )\n        )\n\n    logger.info(f\"Found {len(results)} books on page {page}.\")\n    return Pagination(\n        limit=100,\n        results=results,\n        total=len(results),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page),\n        page=page,\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_by_id","title":"<code>get_by_id(user_id)</code>","text":"<p>Retrieves a user by their ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>User</code> <p>The user's information.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the user with the given ID is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_by_id(1).name\n'Example'\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def get_by_id(self, user_id: int) -&gt; User:\n    \"\"\"\n    Retrieves a user by their ID.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    User\n        The user's information.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the user with the given ID is not found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_by_id(1).name\n    'Example'\n    \"\"\"\n    self._validate_login()\n    logger.info(f\"Getting user by id: {user_id}\")\n    url = f\"{self.base_url}/v1/user/{user_id}/stats:true\"\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json()\n    if not json_data.get(\"success\"):\n        logger.warning(f\"User with ID {user_id} not found.\")\n        raise FileNotFoundError(f\"User with ID {user_id} not found.\")\n\n    user_data = json_data[\"response\"]\n    user_data[\"profile_url\"] = self.base_url + user_data[\"url\"]  # patch field for alias\n    user = User.model_validate(user_data)\n    logger.info(f\"Successfully retrieved user: '{user.name}'\")\n    return user\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_read_stats","title":"<code>get_read_stats(user_id)</code>","text":"<p>Retrieves reading statistics for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <p>Returns:</p> Type Description <code>UserReadStats</code> <p>The user's reading statistics.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_read_stats(self, user_id: int) -&gt; UserReadStats:\n    \"\"\"\n    Retrieves reading statistics for a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n\n    Returns\n    -------\n    UserReadStats\n        The user's reading statistics.\n    \"\"\"\n    self._validate_login()\n    logger.info(f\"Getting read stats for user_id: {user_id}\")\n    url = f\"{self.base_url}/v1/meta_stats/{user_id}\"\n\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    json_data = response.json().get(\"response\", {})\n\n    stats = UserReadStats(\n        user_id=user_id,\n        year=json_data.get(\"ano\"),\n        books_read=json_data.get(\"lido\"),\n        pages_read=json_data.get(\"paginas_lidas\"),\n        total_pages=json_data.get(\"paginas_total\"),\n        percent_complete=json_data.get(\"percentual_lido\"),\n        books_total=json_data.get(\"total\"),\n        reading_speed=json_data.get(\"velocidade_dia\"),\n        ideal_reading_speed=json_data.get(\"velocidade_ideal\"),\n    )\n    logger.info(f\"Successfully retrieved read stats for user_id: {user_id}\")\n    return stats\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_relations","title":"<code>get_relations(user_id, relation, page=1)</code>","text":"<p>Retrieves a user's relations (friends, followers, following).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>relation</code> <code>UsersRelation</code> <p>The type of relation to retrieve.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[int]</code> <p>A paginated list of user IDs.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n[2, 3]\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def get_relations(self, user_id: int, relation: UsersRelation, page: int = 1) -&gt; Pagination[int]:\n    \"\"\"\n    Retrieves a user's relations (friends, followers, following).\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    relation : UsersRelation\n        The type of relation to retrieve.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[int]\n        A paginated list of user IDs.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.get_relations(1, UsersRelation.FRIENDS).results\n    [2, 3]\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/{relation.value}/listar/{user_id}/page:{page}/limit:100\"\n    logger.info(f\"Getting '{relation.value}' for user_id: {user_id}, page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    soup = self.parse_html(response.text)\n    try:\n        users_html = safe_find_all(soup, \"div\", {\"class\": \"usuarios-mini-lista-txt\"})\n        users_id = [int(get_user_id_from_url(get_tag_attr(i.a, \"href\"))) for i in users_html if i.find(\"a\") and getattr(i, \"a\", None)]\n        next_page_link = safe_find(soup, \"div\", {\"class\": \"proximo\"})\n    except (AttributeError, ValueError, IndexError) as e:\n        logger.error(f\"Failed to parse user relations: {e}\")\n        raise ParsingError(\"Failed to parse user relations.\") from e\n\n    logger.info(f\"Found {len(users_id)} users on page {page}.\")\n    return Pagination(\n        results=users_id,\n        limit=100,\n        page=page,\n        total=len(users_id),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.get_reviews","title":"<code>get_reviews(user_id, page=1)</code>","text":"<p>Retrieves reviews made by a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>The ID of the user.</p> required <code>page</code> <code>int</code> <p>The page number for pagination, by default 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Pagination[BookReview]</code> <p>A paginated list of book reviews.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure of the page changes and parsing fails.</p> Source code in <code>pyskoob/users.py</code> <pre><code>def get_reviews(self, user_id: int, page: int = 1) -&gt; Pagination[BookReview]:\n    \"\"\"\n    Retrieves reviews made by a user.\n\n    Parameters\n    ----------\n    user_id : int\n        The ID of the user.\n    page : int, optional\n        The page number for pagination, by default 1.\n\n    Returns\n    -------\n    Pagination[BookReview]\n        A paginated list of book reviews.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure of the page changes and parsing fails.\n    \"\"\"\n    self._validate_login()\n    url = f\"{self.base_url}/estante/resenhas/{user_id}/mpage:{page}/limit:50\"\n    logger.info(f\"Getting reviews for user_id: {user_id}, page: {page}\")\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    user_reviews = []\n    soup = self.parse_html(response.text)\n    try:\n        reviews_html = safe_find_all(soup, \"div\", {\"id\": re.compile(r\"resenha\\d+\")})\n        for review_elem in reviews_html:\n            review_id = int(get_tag_attr(review_elem, \"id\").replace(\"resenha\", \"\"))\n            book_anchor = safe_find(review_elem, \"a\", {\"href\": re.compile(r\".*\\d+ed\\d+.html\")})\n            book_url = get_tag_attr(book_anchor, \"href\")\n            book_id = int(get_book_id_from_url(book_url))\n            edition_id = int(get_book_edition_id_from_url(book_url))\n            star_rating = safe_find(review_elem, \"star-rating\")\n            rating = float(get_tag_attr(star_rating, \"rate\", \"0\"))\n            comment = safe_find(review_elem, \"div\", {\"id\": re.compile(r\"resenhac\\d+\")})\n            date_str = get_tag_text(safe_find(comment, \"span\"))\n            date = None\n            if date_str:\n                try:\n                    date = datetime.strptime(date_str, \"%d/%m/%Y\")\n                except ValueError:\n                    date = None\n            review_text = \"\"\n            if comment:\n                span = safe_find(comment, \"span\")\n                if span:\n                    siblings = [get_tag_text(sib) for sib in span.next_siblings if hasattr(sib, \"get_text\")]\n                    review_text = \"\\n\".join(siblings).strip()\n            user_reviews.append(\n                BookReview(\n                    review_id=review_id,\n                    book_id=book_id,\n                    edition_id=edition_id,\n                    user_id=user_id,\n                    rating=rating,\n                    review_text=review_text,\n                    reviewed_at=date,\n                )\n            )\n        next_page_link = safe_find(soup, \"a\", {\"string\": \" Pr\u00f3xima\"})\n    except (AttributeError, ValueError, IndexError) as e:\n        logger.error(f\"Failed to parse user reviews: {e}\")\n        raise ParsingError(\"Failed to parse user reviews.\") from e\n\n    logger.info(f\"Found {len(user_reviews)} reviews on page {page}.\")\n    return Pagination(\n        results=user_reviews,\n        limit=50,\n        page=page,\n        total=len(user_reviews),  # Placeholder, actual total is not easily available\n        has_next_page=bool(next_page_link),\n    )\n</code></pre>"},{"location":"users_service/#pyskoob.users.UserService.search","title":"<code>search(query, gender=None, state=None, page=1, limit=100)</code>","text":"<p>Search for users on Skoob.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The search query for usernames or names.</p> required <code>gender</code> <code>UserGender</code> <p>Optional gender filter (M/F), by default <code>None</code>.</p> <code>None</code> <code>state</code> <code>BrazilianState</code> <p>Optional state filter (e.g., <code>SP</code>), by default <code>None</code>.</p> <code>None</code> <code>page</code> <code>int</code> <p>Page number to fetch, by default <code>1</code>.</p> <code>1</code> <code>limit</code> <code>int</code> <p>Number of users per page, by default <code>100</code>.</p> <code>100</code> <p>Returns:</p> Type Description <code>Pagination[UserSearch]</code> <p>A paginated list of users matching the criteria.</p> <p>Raises:</p> Type Description <code>ParsingError</code> <p>If the HTML structure is invalid or parsing fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; service.search(\"example\").page\n1\n</code></pre> Source code in <code>pyskoob/users.py</code> <pre><code>def search(\n    self,\n    query: str,\n    gender: UserGender | None = None,\n    state: BrazilianState | None = None,\n    page: int = 1,\n    limit: int = 100,\n) -&gt; Pagination[UserSearch]:\n    \"\"\"Search for users on Skoob.\n\n    Parameters\n    ----------\n    query : str\n        The search query for usernames or names.\n    gender : UserGender, optional\n        Optional gender filter (M/F), by default ``None``.\n    state : BrazilianState, optional\n        Optional state filter (e.g., ``SP``), by default ``None``.\n    page : int, optional\n        Page number to fetch, by default ``1``.\n    limit : int, optional\n        Number of users per page, by default ``100``.\n\n    Returns\n    -------\n    Pagination[UserSearch]\n        A paginated list of users matching the criteria.\n\n    Raises\n    ------\n    ParsingError\n        If the HTML structure is invalid or parsing fails.\n\n    Examples\n    --------\n    &gt;&gt;&gt; service.search(\"example\").page\n    1\n    \"\"\"\n    self._validate_login()\n\n    url = f\"{self.base_url}/usuario/lista/busca:{query}/mpage:{page}/limit:{limit}\"\n    if gender:\n        url += f\"/sexo:{gender.value}\"\n    if state:\n        url += f\"/uf:{state.value}\"\n\n    response = self.client.get(url)\n    response.raise_for_status()\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    try:\n        user_divs = safe_find_all(\n            soup,\n            \"div\",\n            attrs={\"style\": re.compile(r\"border: 1px solid #e4e4e4\")},\n        )\n        results: list[UserSearch] = []\n\n        for div in user_divs:\n            anchor = safe_find(div, \"a\", attrs={\"href\": re.compile(r\"^/usuario/\\d+-\")})\n            if not anchor:\n                continue\n\n            href = get_tag_attr(anchor, \"href\")\n            full_url = f\"{self.base_url}{href}\"\n            match = re.search(r\"/usuario/(\\d+)-([\\w\\.\\-]+)\", href)\n            if not match:\n                continue\n\n            user_id = int(match.group(1))\n            username = match.group(2)\n            name = get_tag_text(anchor)\n\n            logger.debug(\n                \"User ID: %s / Username: %s / Name: %s / URL: %s\",\n                user_id,\n                username,\n                name,\n                full_url,\n            )\n\n            results.append(\n                UserSearch(\n                    id=user_id,\n                    username=username,\n                    name=name,\n                    url=full_url,\n                )\n            )\n\n        total_tag = safe_find(soup, \"div\", {\"class\": \"contador\"})\n        total_text = get_tag_text(total_tag)\n        total = int(total_text.split(\"encontrados\")[0].strip()) if \"encontrados\" in total_text else 0\n\n        next_page = safe_find(soup, \"a\", {\"class\": \"proximo\"})\n        has_next = next_page is not None\n\n        return Pagination[UserSearch](\n            results=results,\n            page=page,\n            total=total,\n            limit=limit,\n            has_next_page=has_next,\n        )\n\n    except Exception as e:\n        raise ParsingError(\"Failed to parse user search results.\") from e\n</code></pre>"}]}